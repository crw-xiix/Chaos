#include "pch.h"
#include "action.h"


bool ActionPlayLocal::Process(double time)
{
    return false;
}

void ActionPlayLocal::Click()
{
}

ActionMovePlayer::ActionMovePlayer(Unit& who, int x, int y): actor(who)
{
    tx = x;
    ty = y;
}

bool ActionMovePlayer::Process(double time)
{
    float dx = tx - actor.GetXF();
    float dy = ty - actor.GetYF();
    double l = sqrt(dx * dx + dy * dy);
    dx /= l; 
    dy /= l;
    actor.MoveF(actor.GetXF() + dx*time*4, actor.GetYF() + dy*time*4);
    //XXXC CRW - need to store old direction to see if we reversed - went too far, lag, etc.
    if (l < 0.05) {
        actor.Move(tx, ty);
        return true;
    }
    return false;
}

void ActionMovePlayer::Click()
{
}

void Action::Mouse(int mx, int my, int b)
{
    //Do nothing.
}

Action::Action()
{
}
#include "pch.h"
#include "ActionIntro.h"
#include "assetmgr.h"
#include "SDL.h"
#include "game.h"
#include "actionselectserver.h"

ActionIntro::ActionIntro()
{
    //Assets are loaded, nothing to do...
}

bool ActionIntro::Process(double time)
{
    int showTime = 4;
    eTime += time;
    if ((eTime > showTime) || (clicked)) {
        int bp = 0;
        nextActions.push_back(new ActionSelectServer());
        return true;
    }
    int alpha = 255;

    if (eTime < 1) {
        alpha = (int ((255) * eTime));
    }
    if (eTime > (showTime-1)) {
        alpha = (int((255) * (showTime-eTime)));
    }
    SDL_Rect rect;
    SDL_Texture* img = AssetMgr::GetAll("INTRO",rect);
    int i = SDL_SetTextureAlphaMod(img, alpha);

    //GoodDoge found the line below
    i =SDL_SetTextureBlendMode(img, SDL_BLENDMODE_BLEND);

    int x = (Display::Width - 600) >> 1;
    int y = (Display::Height- 300) >> 1;
    SDL_Rect dest{ x,y,600,300 };
    SDL_SetRenderDrawBlendMode(Display::GetRenderer(), SDL_BLENDMODE_BLEND);
    Display::DrawTexture(img, &rect, &dest);
    SDL_SetRenderDrawBlendMode(Display::GetRenderer(), SDL_BLENDMODE_NONE);
    return false;
}

void ActionIntro::Click()
{
    clicked = true;
}
#include "pch.h"
#include "actionselectserver.h"
#include "assetmgr.h"
#include "game.h"


ActionSelectServer::ActionSelectServer()
{
    location = SDL_Rect {
        (Display::Width - 600) >> 1,
        (Display::Height - 300) >> 1,
        600, 300};

    SDL_Rect temp;
    SDL_Texture* bTex = AssetMgr::GetAll("BUTTON",temp);

    Button *bRemote = new Button(location.x+10, location.y+20, 256, 48);
    bRemote->SetText("Remote:82");
    bRemote->SetTexture(bTex);
    bRemote->SetOnClick(std::bind(&ActionSelectServer::localClick,this));
    

    Button *bLocal = new Button(location.x+10, location.y+80, 256, 48);
    bLocal->SetText("127.0.0.1:82");
    bLocal->SetTexture(bTex);
    bLocal->SetOnClick(std::bind(&ActionSelectServer::remoteClick, this));

    Button* bExit = new Button(location.x + 10, location.y + 140, 256, 48);
    bExit->SetText("Quit");
    bExit->SetTexture(bTex);
    bExit->SetOnClick(std::bind(&ActionSelectServer::quitClick, this));

    controls.push_back(bRemote);
    controls.push_back(bLocal);
    controls.push_back(bExit);
    mouseMan = new MouseManager(&controls);
}

bool ActionSelectServer::Process(double time)
{
    int mx, my;
    uint32_t mouseState = SDL_GetMouseState(&mx, &my);
    mouseMan->Process(mx, my, mouseState);

    eTime += time;
    if ((eTime > 30000) || (clicked)) {
        int bp = 0;
        return true;
    }
    draw();
    return false;
}

void ActionSelectServer::Click()
{
    //clicked = true;
}

void ActionSelectServer::Mouse(int x, int y, int b)
{
}

void ActionSelectServer::localClick()
{
    Url = "ws://127.0.0.1:82/chat";
    Game::gameInstance->onSelectServerCallback(Url);
    clicked = true;
}

void ActionSelectServer::remoteClick()
{
    Url = "ws://71.56.75.25:82/chat";
    Game::gameInstance->onSelectServerCallback(Url);
    clicked = true;
}

void ActionSelectServer::quitClick()
{
    Url = "QUIT";
    Game::gameInstance->onSelectServerCallback(Url);
    clicked = true;
}

void ActionSelectServer::draw()
{
    SDL_Rect rect;
    SDL_Texture* img = AssetMgr::GetAll("MENUBKG", rect);
    int i = SDL_SetTextureAlphaMod(img, 0);
    int x = (Display::Width - 600) >> 1;
    int y = (Display::Height - 300) >> 1;
    SDL_Rect dest{ x,y,600,300 };

    Display::DrawTexture(img, &rect, &dest);
    for (auto c : controls) {
        c->Draw();
    }
    return;
}

MouseManager::MouseManager(std::vector<VisBase*> *items)
{
    viewItems = items;
}

void MouseManager::Process(int mx, int my, int mb)
{
    VisBase* found = nullptr;
    SDL_Point pt{ mx,my };
    for (auto visBase : *viewItems) {
        if (SDL_PointInRect(&pt, &visBase->location)) {
            found = visBase;
        }
    }
    if (found != lastHover) {
        if (lastHover) {
            lastHover->MouseOut();
            lastDown = nullptr;

        }
        if (found) {
            found->MouseIn();
        }
        lastHover = found;
    }
    if (lastHover != nullptr) {
        if (mouseDown != mb) {
            if (mb==1) {
                lastHover->MouseDown();
                lastDown = lastHover;

            }
            else {
                lastHover->MouseUp();
                if (lastDown == lastHover) lastHover->MouseClick(mx,my);
            }
        }
        mouseDown = mb;

    }

}
#include "pch.h"
#include "animation.h"
#pragma once
#include "pch.h"
#include "assetmgr.h"


void AssetMgr::Destroy()
{
	for (auto i : AssetMgr::Images) SDL_DestroyTexture(i.second);
}

bool AssetMgr::Load(std::string filename, std::string nick)
{
	SDL_Texture* texture = IMG_LoadTexture(Display::GetRenderer(), filename.c_str());
	if (texture == nullptr) {
		std::cout << "Failed to load:" << filename << "\n";
	}
	Images[nick] = texture;
	return false;
}

SDL_Texture* AssetMgr::Get(std::string nick, int gridSizeX, int gridSizeY, int x, int y, SDL_Rect& dest) {
	SDL_Texture* tex = Images[nick];
	if (tex == nullptr) return tex;
	dest.x = gridSizeX * x;
	dest.y = gridSizeY * y;
	dest.w = gridSizeX;
	dest.h = gridSizeY;
	return tex;
}

SDL_Texture* AssetMgr::GetAll(std::string nick, SDL_Rect& dest)
{
	SDL_Texture* tex = Images[nick];
	Uint32 fmt;
	int acs;
	dest.x = 0;
	dest.y = 0;
	SDL_QueryTexture(tex, &fmt, &acs, &dest.w, &dest.h);
		
	return tex;
}


//Statics
std::map<std::string, SDL_Texture*> AssetMgr::Images;
#include "pch.h"
#include "button.h"
#include "display.h"
#include "assetmgr.h"

Button::Button(int x, int y, int w, int h)
{
	location = SDL_Rect{ x,y,w,h };
}

void Button::SetText(std::string val)
{
	label = val;
}

void Button::SetTexture(SDL_Texture* tex)
{
	texture = tex;
}

void Button::SetOnClick(std::function<void(void)> func)
{
	onClick = func;
}

void Button::MouseIn()
{
	hover = true;
}

void Button::MouseOut()
{
	hover = false;
}

void Button::MouseDown()
{
	down = true;
}

void Button::MouseUp()
{
	down = false;
}

void Button::DrawNumber(SDL_Rect ilocation, char c)
{
	c = toupper(c);
	int idx = -1;

	if (c >= '0' && c <= '9') {
		idx = (int)c - '0';
	}
	if (c >= 'A' && c <= 'Z') {
		idx = ((int)(c - 'A')) + 10;
	}
	if (idx == -1) return;
	SDL_Rect texRect;
	

	SDL_Texture* fontText = AssetMgr::Get("FONT16",16,16,idx, 0,texRect);
/*
	texRect.w = 16;
	texRect.h = 16;
	texRect.x = idx * 16;
	texRect.y = 0;
*/
	Display::DrawTexture(fontText,   &texRect, &ilocation);

}


void Button::Draw()
{
	SDL_Rect source{ 0, 0, location.w, location.h };
	if (hover) {
		source.y = 48;
	}
	if (down) source.y = 96;
	Display::DrawTexture(texture, &source, &location);
	//Change 16 to font size later on.
	SDL_Rect topLeft = SDL_Rect{ location.x,location.y, 16,16 };
	int xs, ys;
	xs = (location.w - (label.size()*16)) >> 1;
	ys = (location.h - 16) >> 1;
	topLeft.x += xs;
	topLeft.y += ys;
	for (char c : label) {
		DrawNumber(topLeft, c);
		topLeft.x += 16;
	}
}

void Button::MouseClick(int mx, int my)
{
	onClick();
}
#include "pch.h"
#include "console.h"
#include "assetmgr.h"

ConsoleView::ConsoleView(int x, int y, int w, int h, int lines)
{
	window = SDL_Rect{ x, y, w, h };
	maxLines = lines;
}

void ConsoleView::AddLine(std::string text)
{
	data.push_back(text);
	if (data.size() > maxLines) {
		data.pop_front();
	}
}

void ConsoleView::Clear()
{
	data.clear();
}

void ConsoleView::DrawNumber(SDL_Rect location, char c)
{
	c = toupper(c);
	int idx = -1;

	if (c >= '0' && c <= '9') {
		idx = (int)c - '0';
	}
	if (c >= 'A' && c <= 'Z') {
		idx = ((int)(c - 'A')) + 10;
	}
	if (idx == -1) return;
	SDL_Rect texRect;
	SDL_Texture* fontText = AssetMgr::Get("FONT16", 16,16, idx, 0, texRect);
	Display::DrawTexture(fontText, &texRect, &location);
	
}
void ConsoleView::Draw()
{
	SDL_ClipRectSection myClip(window.x, window.y, window.w, window.h);
	//Change 16 to font size later on.
	SDL_Rect topLeft = SDL_Rect{ window.x,window.y, 16,16 };
	for (auto str : data) {
		for (char c : str) {
			DrawNumber(topLeft, c );
			topLeft.x += 16;
		}
		topLeft.x = window.x;
		topLeft.y += 16;
	}
}
#include "pch.h"
#include "display.h"

Display::Display(int width, int height)
	: window(nullptr), renderer(nullptr) 
{
	Display::Width = width;
	Display::Height = height;
	if (SDL_CreateWindowAndRenderer(width, height, 0, &window, &renderer) < 0)
	{
		std::cout << "Failed to create display: " << SDL_GetError() << "\n";
	}
}

Display::~Display()
{
	SDL_DestroyRenderer(renderer);
	SDL_DestroyWindow(window);

	delete displayInstance;
}

void Display::Create(int width, int height)
{
	displayInstance = new Display(width, height);
}

void Display::Clear(Uint8 r, Uint8 g, Uint8 b)
{
	SDL_SetRenderDrawColor(GetRenderer(), r, g, b, 255);
	SDL_RenderClear(GetRenderer());
}

void Display::Present()
{
	SDL_RenderPresent(GetRenderer());
}

void Display::DrawTexture(SDL_Texture* texture)
{
	SDL_RenderCopy(GetRenderer(), texture, nullptr, nullptr);
}

void Display::DrawTexture(SDL_Texture* texture, const SDL_Rect* targetRect)
{
	SDL_RenderCopy(GetRenderer(), texture, nullptr, targetRect);
}

void Display::DrawTexture(SDL_Texture* texture, const SDL_Rect* targetRect, const SDL_Rect* subTexture)
{
	SDL_RenderCopy(GetRenderer(), texture, targetRect, subTexture);
	
}

/*Static members*/
Display* Display::displayInstance;

int Display::Width = 0;
int Display::Height = 0;


SDL_ClipRectSection::SDL_ClipRectSection(int x, int y, int w, int h)
{
	SDL_RenderGetClipRect(Display::GetRenderer(), &oldRect);
	SDL_Rect clip= { x,y,w,h };
	SDL_RenderSetClipRect(Display::GetRenderer(), &clip);
}

SDL_ClipRectSection::~SDL_ClipRectSection()
{
	SDL_RenderSetClipRect(Display::GetRenderer(), &oldRect);
}
#include "pch.h"
#include "pch.h"
#include "game.h"
#include "assetmgr.h"
#include "viewport.h"
#include "actionintro.h"
#include <functional>

//XXXC CRW Need an action for requesting new room, joining room, etc.

Game::Game() : running(true), console{ nullptr }
{
	//socketQueue = new SocketQueue("ws://71.56.75.25:82/chat");
	//socketQueue = new SocketQueue("ws://127.0.0.1:82/chat");
	socketQueue = nullptr;
}


void Game::handleMouse()
{

	int mx, my;
	uint32_t mouseState = SDL_GetMouseState(&mx, &my);
	//Update the hover locations
	viewPort.GetCellAtMouseXY(mx, my, mCellX, mCellY);


	bool tMouseDown = mouseState & SDL_BUTTON_LEFT;
	if (tMouseDown != mouseDown) {   //State changed.
		if (tMouseDown) {
			viewPort.GetCellAtMouseXY(mx, my, lastMouseCell.x, lastMouseCell.y);
		}
		else { //Upclick
			int imx, imy;
			viewPort.GetCellAtMouseXY(mx, my, imx, imy);
			if ((imx == lastMouseCell.x) && (imy = lastMouseCell.y)) {
				click();
				lastMouseCell.x = -1;
				lastMouseCell.y = -1;
			}
		}
		mouseDown = tMouseDown;
	}
}

void Game::click()
{
	if (actions.size() > 0) {
		actions[actions.size() - 1]->Click();
		return;
	}
	int sp, su;
	//Bail out, out of range click
	if ((lastMouseCell.x < 0) || (lastMouseCell.y < 0)) return;
	if ((lastMouseCell.x >=Map::Size) || (lastMouseCell.y > Map::Size)) return;

	if (getCharacterAt(lastMouseCell.x, lastMouseCell.y, sp, su)) {
		//We have a character......
		int bp = 0;
		if (sp == curPlayer) {
			if (su != selUnit) {
				selectUnit(sp, su);
			};
		}
	}
	else {
		if (selUnit != -1) {
			if (pathFinder->GetRange(lastMouseCell.x, lastMouseCell.y) > -1) {
				//This should be a valid move.

				auto& thisUnit = players[curPlayer].GetUnit(selUnit);
				std::string msg = "Move to:";
				msg += std::to_string(lastMouseCell.x) + " ";
				msg += std::to_string(lastMouseCell.y) + " ";
				std::string test = "{\"request\":\"create\"}";
				//console->AddLine(msg);
				console->AddLine(msg);
				if (socketQueue) {
					socketQueue->Send(test);
				}
				auto thePath = pathFinder->GetPathTo(lastMouseCell.x, lastMouseCell.y);
				for (auto me : thePath) {
					addAction(new ActionMovePlayer(thisUnit, me.x, me.y));
					/*actions.insert(actions.begin(), ActionMovePlayer(thisUnit, me.x, me.y));
					actions.insert()*/
				}
				//thisUnit.Move(lastMouseCell.x, lastMouseCell.y);
				int bp = 0;
			}
		}
		selUnit = -1;
		pathFinder->ResetMap();
	}
}

void Game::selectUnit(int sp, int su)
{
	int bp = 0;
	selUnit = su;
	pathFinder->DoUnitMaxDistanceTravel(players[curPlayer].GetUnit(selUnit),10);
}



bool Game::getCharacterAt(int cx, int cy, int& sPlayer, int& sUnit)
{
	int pnum = 0;
	int unum = 0;
	for (auto iplayer : players) {
		for (auto unit : iplayer.GetUnits()) {
			if ((unit.GetX() == cx) && (unit.GetY() == cy)) {
				sPlayer = pnum;
				sUnit = unum;
				return true;
			}
			unum++;
		}
		pnum++;
	}
	return false;
}

void Game::onSelectServerCallback(std::string url)
{
	if (url == "QUIT") {
		running = false;
	}
	socketQueue = new SocketQueue(url);
	socketQueue->Start();
}

//This has to be static unless we want to pass 100K vars around.
//Each action, when it closes, adds an action.
void Game::addAction(Action* action, Action* ref)
{
	if (ref == nullptr) {
		gameInstance->actions.push_back(action);
	}/*
	else {
		for (int i = 0; i < gameInstance->actions.size(); i++) {
			if 
		}
		if (gameInstance->actions.find(ref) != gameInstance->end()) {
			//insert before 

		}
	}*/
}

//static
void Game::Create()
{
	gameInstance = new Game();
}

//static
void Game::ProcessEvents()
{
	SDL_Event e;
	
	while (SDL_PollEvent(&e))
	{
		if (e.type == SDL_QUIT)
		{
			gameInstance->running = false;
		}
	}
	if (gameInstance->socketQueue) {
		gameInstance->socketQueue->Process();
		//int sz = gameInstance->socketQueue->Avail();
		if (gameInstance->socketQueue->Avail()) {
			//The temp is for setting breakpoints
			std::string temp = gameInstance->socketQueue->Get();
			gameInstance->console->AddLine(temp);
			std::cout << temp << std::endl;
			int bp = 0;
		}
	}

}

bool Game::Process() {
	last = now;
	now = SDL_GetPerformanceCounter();

	double deltaTime = (double)((now- last)  / (double)SDL_GetPerformanceFrequency());
	//std::cout << "Frame time: " << deltaTime << "\n";
	const uint8_t* ks = SDL_GetKeyboardState(NULL);
	if (ks[SDL_SCANCODE_W]) cy -= 0.001;
	if (ks[SDL_SCANCODE_S]) cy += 0.001;
	if (ks[SDL_SCANCODE_A]) cx -= 0.001;
	if (ks[SDL_SCANCODE_D]) cx += 0.001;

	viewPort.SetCamera(cx, cy);
	viewPort.Update(1);
	SDL_Rect myRect;

	//Don't need to clear anything now
		//Display::Clear(0, 0, 0);
	//Get the background up there.........
	SDL_Texture* tempTex = AssetMgr::GetAll("BKG", myRect);
	SDL_Rect screen = { 0,0,1600,800 };
	SDL_RenderSetClipRect(Display::GetRenderer(), &screen);
	Display::DrawTexture(tempTex, &myRect, &screen);
	//Ref out for mCell*
	//Draw the map
	viewPort.Draw(*gameMap, players, pathFinder);
	SDL_RenderSetClipRect(Display::GetRenderer(), &screen);
	//Do actions, if they need to draw....

	size_t size = actions.size();
	if (size > 0) {
		//We need the last Action/Current Action iterator, so we can delete later.
		auto location = (actions.end() - 1);
		//Now we have the action...
		Action* action = *location;
		if (action->Process(deltaTime)) {
			//We have to delete the current one before we can add the new one(s) on top...
			std::list<Action*> tempActions = action->GetNext();
			actions.erase(location);
			if (tempActions.size() != 0) {
				for (auto a : tempActions) {
					addAction(a);
				}
			}
			//Must do this last.
			delete action;
		}
	}
	//No mouse during action time for now
	handleMouse();

	console->Draw();
	//Draw the UI......
	return running;
}

void Game::StartUp(int x, int y)
{
	gameMap = new Map();
	gameMap->Generate();

	pathFinder = new PathFinder(*gameMap);

	AssetMgr::Load("assets/landscape.png", "LAND");
	AssetMgr::Load("assets/background.png", "BKG");
	AssetMgr::Load("assets/Dudes.png", "UNITS");
	AssetMgr::Load("assets/highlights.png", "HIGHLIGHT");
	AssetMgr::Load("assets/font16.png", "FONT16");
	AssetMgr::Load("assets/intro.png", "INTRO");
	AssetMgr::Load("assets/menubkg.png", "MENUBKG");
	AssetMgr::Load("assets/button.png", "BUTTON");
			
	//These numbers come from the background image........
	viewPort = ViewPort(325, 75, 1225, 675, 1.0f);

	console = new ConsoleView(16, 464, 272, 320, 18);
	console->AddLine("Starting");
	console->AddLine("testing 1234567890123456789012345678901234");
	GamePlayer player;
	players.push_back(player);
	curPlayer = 0;
	selUnit = -1; //No unit;
	
	//Get our time setup properly.....
	now = SDL_GetPerformanceCounter();
	addAction(new ActionIntro());
}

void Game::NextPlayer()
{
	curPlayer++;
	curPlayer = curPlayer % players.size();
}

Game::~Game()
{
	delete socketQueue;
	delete console;
	delete gameInstance;
	
}



/*private static members*/
Game* Game::gameInstance;

int Game::mCellX = 5;
int Game::mCellY = 5;
#include "pch.h"
#include "gameplayer.h"

GamePlayer::GamePlayer()
{
	for (int i = 0; i < initUnits; i++)
	{
		units.push_back(Unit(((UnitType)i), 10 + rand() % 12, 5 + rand() % 12));
	}
}

std::string GamePlayer::GetJson() {
	std::string result = "{";
	for (int i = 0; i < initUnits; i++)
	{
		result += units[i].GetJson();
		if (i < (initUnits - 1)) result += ",";
		result += "\n";
	}
	result += "}\n";
	return result;
}#include "pch.h"
#include "display.h"
#include "game.h"
#include "perlinmap.h"
#include <SDL_image.h>
#include "assetmgr.h"
#include "map.h"
#include "viewport.h"
#include "../3rd/easywsclient.hpp"

#ifdef _WIN32
#pragma comment( lib, "ws2_32" )
#include <WinSock2.h>
#endif

#include <assert.h>
#include <stdio.h>
#include <string>
#include <memory>
#include "unit.h"
#include "../3rd/jute.h"





int nomain2()
{
    using easywsclient::WebSocket;
#ifdef _WIN32
    INT rc;
    WSADATA wsaData;
    rc = WSAStartup(MAKEWORD(2, 2), &wsaData);
    if (rc) {
        printf("WSAStartup Failed.\n");
        return 1;
    }
#endif
    

    //XXXC CRW need to thread this, thread safe queue for send/recv

    GamePlayer gp;
    std::unique_ptr<WebSocket> ws(WebSocket::from_url("ws://71.56.75.25:82/chat"));
    assert(ws);
    ws->send("goodbye");
    ws->send("hello");
    while (ws->getReadyState() != WebSocket::CLOSED) {
        WebSocket::pointer wsp = &*ws; // <-- because a unique_ptr cannot be copied into a lambda
        ws->poll();
        ws->dispatch([wsp,&gp](const std::string& message) {
            printf(">>> %s\n", message.c_str());
            if (message == "world") { wsp->close(); }

            //XXXC some bullshit.....
            //we got a message, lets reply with status
            std::string wtf = gp.GetJson();
            wsp->send(wtf);
            });
    }
#ifdef _WIN32
    WSACleanup();
#endif
    // N.B. - unique_ptr will free the WebSocket instance upon return:
    return 0;
}


int main(int argc, char* argv[])
{
    //nomain2();
	if (SDL_Init(SDL_INIT_EVERYTHING) != 0)
	{
		std::cout << "Failed to init SDL " << SDL_GetError() << "\n";
		return -1;
	}
	

	Game::Create();
	Display::Create(1600, 800);
	IMG_Init(IMG_INIT_PNG);

	Game::gameInstance->StartUp(1600, 800);

	while (Game::IsRunning())
	{
		Game::ProcessEvents();
        if (!Game::gameInstance->Process()) break;
		Display::Present();
		SDL_Delay(11);
	}
	AssetMgr::Destroy();
	SDL_Quit();
	return 0;
}
#include "pch.h"
#include "map.h"
#include "perlinmap.h"

Map::Map()
{

}

void Map::Generate()
{
	PerlinMap noise(Size,Size);
	noise.Randomize(400000);
	noise.MakePerlin();
	noise.Normalize();

	for (int y = 0; y < Size; y++) {
		for (int x = 0; x < Size; x++) {
			int val =noise.GetTerrain(x, y, 9);
			
			map[y][x] = MapTile(val);
		}
	}

}

int Map::get(int x, int y)
{

	int val = map[y][x].GetTestCellVal();
	return val;
	
}

MapTile& Map::Get(int x, int y)
{
	return map[x][y];
}

#include "pch.h"
#include "maptile.h"
#include "assetmgr.h"
#include "map.h"
#include "unit.h"
#include "gameplayer.h"

int MapTile::getSpeed()
{

	switch (type) {
	case MapCellType::MARSH: return 3;
	case MapCellType::GRASS: return 1;
	case MapCellType::STEPPE: return 2;
	case MapCellType::HILL: return 7;
	case MapCellType::ROCKY: return 14;
	case MapCellType::DESTROYED: return 3;
	}
	//Impassable land...
	return 255;
}

MapTile::MapTile()
{

}

//Will have to figure out how to make it prettier
MapTile::MapTile(int val)
{
	imgOffset = rand() % 8;
	type = (MapCellType) val;
	speed = getSpeed();
}

MapTile::MapTile(MapCellType type)
{
	//this will work for now.....
	imgOffset = rand() % 8;
	this->type = type;
	speed = getSpeed();
}

void MapTile::Draw(SDL_Rect dest)
{
	SDL_Rect myRect;
	SDL_Texture* tempTex = AssetMgr::Get("LAND", Map::TileSize, Map::TileSize, imgOffset,(int) type, myRect);
	Display::DrawTexture(tempTex, &myRect, &dest);
	if (selected) {
		SDL_Texture* highlightTex = AssetMgr::Get("HIGHLIGHT", Map::TileSize, Map::TileSize, 0, 0, myRect);
		Display::DrawTexture(highlightTex, &myRect, &dest);

		//SDL_Texture* dude = AssetMgr::Get("UNITS", Map::TileSize, 0, 2, myRect);
		//Display::DrawTexture(dude, &myRect, &dest);
		
		//Unit dude(UnitType::Warrior);
		//dude.Draw(dest);

		GamePlayer myPlayer;
		myPlayer.GetUnits();
		
	}
}
#include "pch.h"
#include "pathfind.h"
#include <set>
#include <algorithm>
#include <random>





PathFinder::PathFinder(Map& imap) : map(imap)
{
	dRange = new std::array<std::array<int, Map::Size>, Map::Size>();
}

void PathFinder::DoUnitMaxDistanceTravel(const Unit& who, int val)
{
	ResetMap();
	calcFlood(who.GetX(),who.GetY(),who.GetSpeed());
}

void PathFinder::DoUnitMaxDistanceAttack(const Unit& who, int val, bool aerial)
{

}

int PathFinder::GetRange(int x, int y)
{
	return (*dRange)[y][x];
}

void PathFinder::ResetMap()
{
	for (int y = 0; y < Map::Size; y++) {
		for (int x = 0; x < Map::Size; x++) {
			//These are just other ways to access it...
			//dMap->at(j).at(i) = -1;
			//dMap->at(j)[i] = -1;
			//(*dMap)[y][x] = -1;
			(*dRange)[y][x] = -1;
		}
	}
}

PathFinder::xyRange PathFinder::pathGood(int x, int y)
{
	int d = ((*dRange)[y][x]);
	if (d < 0) d = Map::Size*2+1;
	return xyRange{ x,y,d };
}

/// <summary>
/// Get path to starts at x, y, and ends at pathfinder 0.  
/// This shall not be called if a path is not already possible.
/// </summary>
/// <param name="x">target x cell</param>
/// <param name="y">targer y cell</param>
/// <returns></returns>
std::vector<SDL_Point> PathFinder::GetPathTo(int x, int y)
{
	int sx = x;
	int sy = y;
	typedef std::tuple<int, int, int> xyRange;
	std::vector<xyRange> found;

	std::vector<SDL_Point> thePath;
	//This is our starting location.
	
	thePath.push_back(SDL_Point{ x,y });

	//It's zero when we find the target
	while ((*dRange)[y][x] > 1)
	{
		int d = (*dRange)[y][x];

		//std::cout << "Pos" << x << "," << y << " Dist: " << d << "\n";

		found.push_back(pathGood(x, y - 1));
		found.push_back(pathGood(x, y + 1));
		found.push_back(pathGood(x - 1, y));
		found.push_back(pathGood(x + 1, y));

		auto rng = std::default_random_engine{};
		std::shuffle(found.begin(), found.begin()+2,rng);

		std::sort(found.begin(), found.end() , 
			[](xyRange& a, xyRange& b) {
				return std::get<2>(a) < std::get<2>(b);
			}
			);

		//This gives us a little randomness in motion so they don't walk straight lines.
		int d1;
		int idx = 0;
		if (std::get<2>(found[0]) == std::get<2>(found[1])) {
			idx = rand() % 2;
		}

		std::tie(x, y, d1) = found[idx];

		d = d1;
		found.clear();
		thePath.push_back( SDL_Point{ x,y });
		if (thePath.size() > 20) {
			int bp = 0;
		}
	}
	return thePath;
}

bool PathFinder::rangeOpen(int x, int y, int& speed)
{
	speed = 255;
	if (x < 0) return false;
	if (y < 0) return false;
	if (x >= Map::Size) return false;
	if (y >= Map::Size) return false;
	speed = map.Get(x, y).GetSpeed();
	if (speed < 99) {
		int bp = 0;
	}
	//if (((*dMap)[x][y]) != 0) return false;
	if (((*dRange)[y][x]) == -1) return true;
	return false;

}

void PathFinder::calcFlood(int x, int y, int maxSpeed)
{
	typedef std::tuple<int, int, int> xyRange;
	std::set<xyRange> found;
	found.insert(xyRange(x, y, 1));
	int speed = 0;
	while (found.size() > 0)
	{
		std::set<xyRange> mainSet;
		int sx, sy, d;
		for (xyRange xyz : found) {
			std::tie(sx, sy, d) = xyz;
			//Set this spot.
			(*dRange)[sy][sx] = d;
			if (rangeOpen(sx, sy - 1, speed)) mainSet.insert(xyRange(sx, sy - 1, d + speed));
			if (rangeOpen(sx, sy + 1, speed)) mainSet.insert(xyRange(sx, sy + 1, d + speed));
			if (rangeOpen(sx + 1, sy, speed)) mainSet.insert(xyRange(sx + 1, sy, d + speed));
			if (rangeOpen(sx - 1, sy, speed)) mainSet.insert(xyRange(sx - 1, sy, d + speed));
		}
		found.clear();
		for (xyRange xy : mainSet) {
			std::tie(sx, sy, d) = xy;
			bool isFound = false;
			//Figure out if that position is already found, we don't want to search 2-20x.
			//double searching makes bad paths.
			for (auto position : found) {
				int isx, isy, isd;
				std::tie(isx, isy, isd) = position;
				if ((sx == isx) && (sy == isy)) {
					isFound = true;
					break;
				}
			} //Back from break above
			if (!isFound) {
				//Check our max speed now
				if (d <= maxSpeed) {
					found.insert(xy);
				}
			}
			else {
				int bp = 0;
			}
		}
		mainSet.clear();
	}
}

PathFinder::~PathFinder()
{
	delete dRange;
}#include "pch.h"#pragma once
#include "pch.h"
#include "perlinmap.h"
#include <random>
#include "display.h"

PerlinMap::PerlinMap(int x, int y)
{
	width = x;
	height = y;

	evalues = new float[(size_t)x * y];
	svalues = new float[(size_t)x * y];
}

PerlinMap::~PerlinMap()
{
    if (svalues) delete[] svalues;
    if (evalues) delete[] evalues;
}

void PerlinMap::MakePerlin()
{
	float fbias = 2.0f;
	for (int x = 0; x < width; x++) {
		for (int y = 0; y < height; y++)
		{
			float fNoise = 0.0f;
			float fScaleAcc = 0.0f;
			float fScale = 1.0f;

			for (int o = 0; o < (octaves-1); o++)
			{
				int nPitch = width >> o;
				int nSampleX1 = (x / nPitch) * nPitch;
				int nSampleY1 = (y / nPitch) * nPitch;

				int nSampleX2 = (nSampleX1 + nPitch) % width;
				int nSampleY2 = (nSampleY1 + nPitch) % width;

				float fBlendX = (float)(x - nSampleX1) / (float)nPitch;
				float fBlendY = (float)(y - nSampleY1) / (float)nPitch;

				float fSampleT = (1.0f - fBlendX) * svalues[nSampleY1 * width + nSampleX1] + fBlendX * svalues[nSampleY1 * width + nSampleX2];
				float fSampleB = (1.0f - fBlendX) * svalues[nSampleY2 * width + nSampleX1] + fBlendX * svalues[nSampleY2 * width + nSampleX2];

				fScaleAcc += fScale;
				fNoise += (fBlendY * (fSampleB - fSampleT) + fSampleT) * fScale;
				fScale = fScale / fbias;
			}
			// Scale it
			evalues[y * width + x] = fNoise / fScaleAcc;
		}
	}
}

void PerlinMap::Normalize()
{
	float max = -100.0f;
	float min = 100.0f;
	for (int i = 0; i < (width * height); i++) {
		if (evalues[i] > max) max = evalues[i];
		if (evalues[i] < min) min = evalues[i];
	}
	float diff = max - min;
	float mult = 1 / diff;
	for (int i = 0; i < (width * height); i++) {
		evalues[i] -= min;
		evalues[i] *= mult;
	}
}



int PerlinMap::GetTerrain(int x, int y, int max)
{
	//Scale to requested level
	int val = (int)(evalues[y * width + x] * max);

	if (val < 0) val = 0;
	if (val >= max) val = max - 1;
	return val;
}

//static
void PerlinMap::TestDraw()
{
	/*
	int w = 512;
	int h = 512;
	int rval = rand() % 500;
	PerlinMap map = PerlinMap(w, h);
	map.Randomize(107);
	map.MakePerlin();
	map.Normalize();
	SDL_Renderer* ren = Display::GetRenderer();
	//now to draw it.........   ugh
	for (int y = 0; y < h; y++) {
		for (int x = 0; x < w; x++) {
			int val = map.GetTerrain(x, y, 8) * 32;
			if (val > 255) val = 255;
			if (val < 0) val = 0;
			SDL_SetRenderDrawColor(ren, val, val, val, 255);
			SDL_RenderDrawPoint(ren, x, y);
		}
	}
	*/
}

void PerlinMap::Randomize(int iseed)
{
    std::mt19937 gen(iseed);
    std::uniform_real_distribution<> dis(0.0, 1.0);
    for (int x = 0; x < width; x++) {
        for (int y = 0; y < height; y++) {
            svalues[y * width + x] = dis(gen);
        }
    }
}

#include "pch.h"
#include "socketqueue.h"
#include "../3rd/easywsclient.hpp"

/* Ugly Windows code.....*/

#ifdef _WIN32
#pragma comment( lib, "ws2_32" )
#include <WinSock2.h>
#endif

SocketQueue::SocketQueue(std::string url)
{
    this->url = url;
	instance = this;
}

bool SocketQueue::Send(std::string val)
{
    qOut.Enqueue(val);
    return true;
}

bool SocketQueue::Avail()
{
    return (qIn.Size() > 0);
}

std::string SocketQueue::Get()
{
    return qIn.Dequeue();
}

bool SocketQueue::Start()
{
    using easywsclient::WebSocket;
    //More ugly Windows code.
#ifdef _WIN32
    INT rc;
    WSADATA wsaData;
    rc = WSAStartup(MAKEWORD(2, 2), &wsaData);
    if (rc) {
        printf("WSAStartup Failed.\n");
        return 1;
    }
#endif
    ws = std::unique_ptr<WebSocket>(WebSocket::from_url(url));
}

void SocketQueue::Process()
{
    using easywsclient::WebSocket;
    if (ws) {
        if (ws->getReadyState() != WebSocket::CLOSED) {
            WebSocket::pointer wsp = &*ws; // <-- because a unique_ptr cannot be copied into a lambda
            
            //Send if there is something to send.
            if (SocketQueue::instance->qOut.Size() > 0) {
                ws->send(qOut.Dequeue());
            }
            ws->poll();
            ws->dispatch([wsp](const std::string& message) {
                printf(">>> %s\n", message.c_str());
                SocketQueue::instance->qIn.Enqueue(message);
                //we got a message, lets reply with status
                //std::string wtf = p.GetJson();
                //wsp->send(wtf);
                });
        }
        else {
            Stop();
        }
    }
}

void SocketQueue::Stop()
{
#ifdef _WIN32
    WSACleanup();  //More Windows slop
#endif
    //This is to notify the game that the socket died.
    SocketQueue::instance->qIn.Enqueue("{\"socket\":\"closed\"}");
    // N.B. - unique_ptr will free the WebSocket instance upon return:
}

//statics
SocketQueue* SocketQueue::instance = nullptr;

#include "pch.h"
#include "unit.h"
#include "map.h"
#include "display.h"
#include "assetmgr.h"

Unit::Unit(UnitType type, int x, int y)
{
	this->type = type;

	this->x = (float) x;
	this->y = (float) y;

	texture = AssetMgr::Get("UNITS", Map::TileSize, Map::TileSize, 0, (int)type, rect);

	weapon = WeaponType::None;
	hp = 0;
	speed = 0;
	range = 0;
	damage = 0.0f;

	//Weapon type and stats depend on unit type.
	switch (type)
	{
	case UnitType::Warrior:
		weapon = WeaponType::Melee;
		hp = 100.0f;
		speed = 12;
		range = 1;
		damage = 20.0f;
		break;

	case UnitType::Spear:
		weapon = WeaponType::Melee;
		hp = 100.0f;
		speed = 24;
		range = 1;
		damage = 35.0f;
		break;

	case UnitType::Archer:
		weapon = WeaponType::Ranged;
		hp = 75.0f;
		speed = 30;
		range = 5;
		damage = 20.0f;
		break;

	case UnitType::Wizard:
		weapon = WeaponType::Magic;
		hp = 50.0f;
		speed = 20;
		range = 2;
		damage = 40.0f;
		break;
	}
}

std::string jsonify(std::string key, std::string value) {
	std::string result = "";
	result += " \""+key+"\": \"";
	result += value + "\"";
	return result;
}

std::string Unit::GetJson()
{
	std::string result = "{\r\n";
	result += jsonify("hp", std::to_string(hp));
	result += ",\r\n";
	result += jsonify("x", std::to_string(GetX()));
	result += ",\r\n";
	result += jsonify("y", std::to_string(GetY()));
	result += "\r\n";
	result += "}\r\n";
	return result;
}

void Unit::Draw(SDL_Rect dest)
{
	Display::DrawTexture(texture, &rect, &dest);
}
#include "pch.h"
#include "viewport.h"
#include "assetmgr.h"
#include "game.h"

bool cellDistanceShow = false;

ViewPort::ViewPort(int x, int y, int w, int h, float zoom)
{
	topX = x; topY = y; width = w; height = h;
	zoom = 1.0f;
	camTX = 0;
	camTY = 0;
	camX = 0;
	camY = 0;
}

void ViewPort::SetCamera(double &x, double &y)
{
	if (x < 0) x = 0;
	if (y >= 1) y = 1;
	if (x >= 1) x = 1;
	if (y <= 0) y = 0;
	camTX = x ;
	camTY = y ;
}

//Ghetto cam pan
void ViewPort::Update(int ms)
{
	double delay = 9.0f;
	camX = ((camX*delay + camTX) / (delay+1.0));
	camY = ((camY*delay + camTY) / (delay+1.0));
}

int asdf = 0;
void ViewPort::Draw(Map& map, std::vector<GamePlayer> players, PathFinder *pathFinder)
{
	SDL_ClipRectSection myClip(topX, topY, width, height);
	SDL_Rect destRect;
	destRect.w = Map::TileSize;
	destRect.h = Map::TileSize;
	int maxXCells = width / destRect.w;
	int maxYCells = height / destRect.h;
	
	//Camera X/Y in cell grid location
	int cx = (int)(camX * Map::Size );
	int cy = (int)(camY * Map::Size );

	//Camera X/Y in pixel location
	int MScx = (int)(camX * Map::Size * Map::TileSize);
	int MScy = (int)(camY * Map::Size * Map::TileSize);
	
	//Cell grid offset from 0,0 of each cell
	int pcx = MScx % (Map::TileSize);
	int pcy = MScy % (Map::TileSize);
	
	if (cx < 0) cx = 0;
	if (cy < 0) cy = 0;
	
	int maxXCam = Map::Size - (width / Map::TileSize) -1;
	int maxYCam = Map::Size - (height / Map::TileSize) -1;

	if (cx > (maxXCam)) cx = maxXCam;
	if (cy > (maxYCam)) cy = maxYCam;
	
	for (int y = 0; y < maxYCells+2 /* scale*/; y++) {
		for (int x = 0; x < maxXCells+1/*scale*/; x++) {
			destRect.x = x * Map::TileSize + topX -pcx;
			destRect.y = y * Map::TileSize + topY -pcy;
			map.Get(cx + x, cy + y).Draw(destRect);

			//Now we need to handle the cells in the pathfinder.....
			if (pathFinder->GetRange(cx + x, cy + y) > 0) {
				SDL_Rect myRect;
				SDL_Texture* highlightTex = AssetMgr::Get("HIGHLIGHT", Map::TileSize, Map::TileSize, 0, 2, myRect);
				Display::DrawTexture(highlightTex, &myRect, &destRect);

				//This is for testing only....
				if (cellDistanceShow) {
					DrawNumber(destRect, pathFinder->GetRange(cx + x, cy + y));
				}
			}
			//Highlight Current Cell under the mouse.........
			if ((Game::mCellX == (cx + x)) && ((Game::mCellY == cy + y))) {
				SDL_Rect myRect;
				SDL_Texture* highlightTex = AssetMgr::Get("HIGHLIGHT", Map::TileSize, Map::TileSize, 0, 0, myRect);
				Display::DrawTexture(highlightTex, &myRect, &destRect);
			}
		}
	}

	for (auto& player : players)
	{
		for (auto unit : player.GetUnits())
		{
			destRect.x =(int) ((unit.GetXF()-(float)cx ) * (float)Map::TileSize + (float)topX - (float)pcx);
			destRect.y =(int) ((unit.GetYF()-(float)cy ) * (float)Map::TileSize + (float)topY - (float)pcy);
			unit.Draw(destRect);
		}
	}
}

void ViewPort::DoSomething()
{
	///some code......................
}
/// <summary>
/// 
/// </summary>
/// <param name="mx">Mouse x</param>
/// <param name="my">Mouse y</param>
/// <param name="x">Ref OUT cell x</param>
/// <param name="y">Ref OUT cell y</param>
/// <returns>Cell location in map of map cell under cursor.....</returns>
bool ViewPort::GetCellAtMouseXY(int mx, int my, int& x, int& y)
{
	
	mx -= topX;
	my -= topY;

	mx = (int)(Map::Size*Map::TileSize * camX + mx) / Map::TileSize;
	my = (int)(Map::Size*Map::TileSize * camY + my) / Map::TileSize;

	if (camX > .1) {
		int bp = 0;
	}

	x = mx;
	y = my;

	return false;
}

void ViewPort::RenderTextureAt(int cx, int cy, int ocx, int ocy, SDL_Texture* tex, SDL_Rect* sourceRect)
{
	return;
}

bool ViewPort::MouseInViewPort(int x, int y)
{
	if (x < topX) return false;
	if (y < topY) return false;
	if (x >= (topX + width)) return false;
	if (y >= (topY + height)) return false;
	return true;
}

void ViewPort::DrawNumber(SDL_Rect location, int value)
{
	int x = location.x;
	int y = location.y;
	char buf[80];
	snprintf(buf,15,"%d",  value);
	//char* temp = itoa(value);
	for (char c : buf) {
		SDL_Rect myRect;
		SDL_Rect textRect;
		textRect.x = x;
		textRect.y = y;
		textRect.w = 16;
		textRect.h = 16;
		SDL_Texture* fontText = AssetMgr::Get("FONT16", 16, 16, (c - '0'), 0, myRect);
		Display::DrawTexture(fontText, &myRect, &textRect);
		x += 16;
	}
}
#pragma once
#include "pch.h"
#include "unit.h"

class Action {
public:
	//Returns true if Process is complete.
	virtual bool Process(double time) = 0;
	virtual void Click() = 0;
	virtual void Mouse(int mx, int my, int b);
	inline std::list<Action*> GetNext() { return nextActions; }
	Action();
protected: 

	std::list<Action*> nextActions;
private:
	

};

class ActionPlayLocal : public Action {
	bool Process(double time);
	void Click();
};


class ActionMovePlayer : public Action {
	int tx, ty;
	Unit& actor;
public:
	ActionMovePlayer(Unit& who, int x, int y);
	bool Process(double time);
	void Click();
};


//XXXC CRW  Need action request, action join, action waiting, action playing and action 
//game over.  Also have to do point inserts on action lists.
#pragma once
#include "action.h"

class ActionIntro : public Action {
public:
	ActionIntro();
	bool Process(double time);
	void Click();
private:
	bool clicked = false;
	SDL_Texture* tex = nullptr;
	double eTime = 0;
};
#pragma once
#pragma once
#include "action.h"
#include "button.h"

class MouseManager {
public:
	MouseManager(std::vector<VisBase*> *items);
	void Process(int mx, int my, int mb);
private:
	std::vector<VisBase*> *viewItems;
	VisBase* lastHover = nullptr;
	VisBase* lastDown = nullptr;
	int mouseDown = 0;
	
};

class ActionSelectServer : public Action {
public:
	ActionSelectServer();
	bool Process(double time);
	void Click();
	void Mouse(int x, int y, int b) override;
	std::string Url;
protected:
	void localClick();
	void remoteClick();
	void quitClick();
private:
	MouseManager *mouseMan;
	SDL_Rect location;
	std::vector<VisBase*> controls;
	std::string serverUrl = "";
	bool clicked = false;
	double eTime = 0;
	void draw();
};

#pragma once

class Animation
{
private:

public:
	virtual ~Animation() = default;

	virtual void Start() = 0;
};

class AnimationArrow : public Animation
{
private:
public:
};#pragma once
#include "pch.h"
#include "display.h"
#include "SDL_image.h"

class AssetMgr {
private:
	
	
	
public:
	static void Destroy();
	static std::map<std::string, SDL_Texture*> Images;
	static bool Load(std::string filename, std::string nick);
	static SDL_Texture* Get(std::string nick, int gridSizeX, int GridSizeY, int x, int y, SDL_Rect& dest);
	static SDL_Texture* GetAll(std::string nick, SDL_Rect& dest);
};

#pragma once
#include "pch.h"
#include <functional>

class VisBase {
public:
	virtual void MouseIn() = 0;
	virtual void MouseOut() = 0;
	virtual void MouseDown() = 0;
	virtual void MouseUp() = 0;
	virtual void MouseClick(int mx, int my) = 0;
	virtual void Draw() = 0;
protected:
	friend class MouseManager;
	SDL_Rect location{ 0 };
	bool hover = false;
	bool down = false;
};

class Button : public VisBase {
public:
	Button(int x, int y, int w, int h);
	void SetText(std::string val);
	void SetTexture(SDL_Texture* tex);
	void SetOnClick(std::function<void(void)> func);
	void MouseIn() override;
	void MouseOut() override;
	void MouseDown() override;
	void MouseUp() override;
	void DrawNumber(SDL_Rect location, char c);
	void Draw() override;
	void MouseClick(int mx, int my) override;
protected:
	std::function<void(void)> onClick;
	SDL_Texture* texture;
	std::string label;
};
#pragma once
#include "pch.h"
#include "SDL.h"


class ConsoleView {
private:
	std::list<std::string> data;
	SDL_Rect window;
	int maxLines = 10;
public:
	ConsoleView(int x, int y, int w, int h, int lines);
	void AddLine(std::string text);
	void Clear();
	void DrawNumber(SDL_Rect location, char c);
	void Draw();
};

#pragma once
#include "pch.h"

class Display
{
private:
	static Display* displayInstance;

	SDL_Window* window;
	SDL_Renderer* renderer;

	Display(int width, int height);
	~Display();

public:
	static int Width;
	static int Height;

	static void Create(int width, int height);

	static void Clear(Uint8 r, Uint8 g, Uint8 b);
	static void Present();
	
	static void DrawTexture(SDL_Texture* texture);
	static void DrawTexture(SDL_Texture* texture, const SDL_Rect* targetRect);
	static void DrawTexture(SDL_Texture* texture, const SDL_Rect* targetRect, const SDL_Rect* subTexture);

	static inline SDL_Window* GetWindow() { return displayInstance->window; }
	static inline SDL_Renderer* GetRenderer() { return displayInstance->renderer; }
};


class SDL_ClipRectSection {
	SDL_Rect oldRect;
public:
	SDL_ClipRectSection(int x, int y, int w, int h);
	~SDL_ClipRectSection(); 
};#pragma once
#include "map.h"
#include "unit.h"
#include "viewport.h"
#include "pathfind.h"
#include "action.h"
#include "console.h"
#include "socketqueue.h"

class Game
{
public:
	static int mCellX, mCellY;
	static Game* gameInstance;

	static void Create();
	static void ProcessEvents();
	bool Process();
	void StartUp(int x, int y);
	void NextPlayer();
	static inline bool IsRunning() { return gameInstance->running; }
public: //static
	static void addAction(Action* action, Action* ref = nullptr);
	void onSelectServerCallback(std::string url);
private:
	SocketQueue *socketQueue=nullptr;

	bool running= false;
	//Camera Location
	double cx = 0;
	double cy = 0;

	Game();
	~Game();

	//Stuff we need for game
	Map* gameMap = nullptr;
	std::vector<GamePlayer> players;
	ViewPort viewPort;
	ConsoleView* console = nullptr;

	PathFinder* pathFinder = nullptr;

	int curPlayer = -1;
	int selUnit = -1;

	SDL_Point lastMouseCell{ -1,-1 };
	bool mouseDown = false;
	std::vector<Action*> actions;
	Uint64 now = 0;
	Uint64 last = 0;
	void handleMouse();
	void click();
	void selectUnit(int sp, int su);
	//Gets the character at cell x,y (not mouse location)
	bool getCharacterAt(int cx, int cy, int& sPlayer, int& sUnit);

	
};
#pragma once
#include "pch.h"
#include "unit.h"

class GamePlayer {
private:
	std::vector<Unit> units;
	//temp
	static constexpr int initUnits = 4;

public:
	GamePlayer();
	std::string GetJson();
	inline std::vector<Unit>& GetUnits()  { return units; }
	inline Unit& GetUnit(int idx) { return units[idx]; }
};
#pragma once

#include "maptile.h"

class Map {
public:
	friend class PathFind;
	static constexpr int Size = 128;  //Need a power of 2......
	static constexpr int TileSize = 64;
private:
	MapTile map[Size][Size];
public:
	Map();
	void Generate();
	int get(int x, int y);
	MapTile& Get(int x, int y);
	//Stuff to get/set later
	bool highlighted = false;
};
#pragma once
#include "pch.h"

enum class MapCellType {
	DEEP_SEA = 0,
	WATER,
	SHALLOW_WATER,
	MARSH,
	GRASS,
	STEPPE,
	HILL,
	ROCKY,
	SNOW,
	NONE,
	DESTROYED
};

//This is a location on the map, stored inside the map
class MapTile {
private:
	MapCellType type = MapCellType::NONE;
	int imgOffset = 0;
	friend class PathFind;
	int speed = 99;
	int getSpeed();
public:
	bool selected = false;
	MapTile();
	MapTile(int val);
	MapTile(MapCellType type);
	void Draw(SDL_Rect dest);
	inline int GetTestCellVal() { return (int)type; }
	inline int GetTestCellOfs() { return imgOffset; }
	inline int GetSpeed() { return speed; }

};
#pragma once

#include "pch.h"
#include "maptile.h"
#include "map.h"
#include <vector>
#include "unit.h"



class PathFinder {
private:
    typedef std::tuple<int, int, int> xyRange;

    std::array<std::array<int, Map::Size>, Map::Size>* dRange = nullptr;
    std::vector<SDL_Point> path;
    
    void calcFlood(int x, int y, int maxSpeed);
    bool rangeOpen(int x, int y, int &speed);
    Map& map;
    xyRange pathGood(int x, int y);
public:
    PathFinder(Map& map);
    void DoUnitMaxDistanceTravel(const Unit& who, int val);
    void DoUnitMaxDistanceAttack(const Unit& who, int val, bool aerial);
    void ResetMap();

    

    //Current unit is selected, so this should be simple....
    std::vector<SDL_Point> GetPathTo(int x, int y);

    
    /// <summary>
    /// Returns the distance from calculated path.
    /// </summary>
    /// <param name="x"></param>
    /// <param name="y"></param>
    /// <returns>Returns the distance from calculated path.</returns>
    int GetRange(int x, int y);
    
    ~PathFinder();
};
#pragma once

#include <array>
#include <list>
#include <string>
#include <vector>
   
#include <iostream>
#include <sstream>
#include <fstream>

#include <functional>
#include <memory>
#include <map>

#include <SDL.h>
#pragma once



/// <summary>
/// Do not use new on this.  Just put it on the stack.  Loop through until paths are verified, then go out of scope.
/// </summary>
class PerlinMap {
private:
	int seed = 0;
	int width = 0;
	int height = 0;
	float* svalues = nullptr;
	float* evalues = nullptr;
	const int octaves = 6;
public:
	PerlinMap(int x, int y);
	~PerlinMap();
	/// <summary>
	/// Randomizes the source numbers, taking a new seed - if 
	/// </summary>
	void Randomize(int seed);
	void MakePerlin();
	void Normalize();
	//this will be enum soon
	int GetTerrain(int x, int y, int max);
	static void TestDraw();
};#pragma once
#include "pch.h"
#include "threadqueue.h"
#include "../3rd/easywsclient.hpp"

class SocketQueue {
public:
	SocketQueue(std::string url );
	bool Send(std::string val);
	bool Avail();
	std::string Get();
	bool Start();
	void Process();
	void Stop();

private:
	std::unique_ptr<easywsclient::WebSocket> ws;
	std::string url;
	ThreadQueue<std::string> qOut;
	ThreadQueue<std::string> qIn;
//Stuff for thread access...
	static SocketQueue *instance;
};
#pragma once
#include <queue>
#include <mutex>
#include <condition_variable>

// A threadsafe-queue.
template <class T>
class ThreadQueue
{
public:
    ThreadQueue(void)
        : q()
        , m()
        , c()
    {}

    ~ThreadQueue(void)
    {}

    // Add an element to the queue.
    void Enqueue(T t)
    {
        std::lock_guard<std::mutex> lock(m);
        q.push(t);
        c.notify_one();
    }

    //Return the size, avoids stalls on dequeue
    size_t Size() {
        std::unique_lock<std::mutex> lock(m);
        return q.size();
    }

    // Get the "front"-element.
    // If the queue is empty, wait till a element is avaiable.
    T Dequeue(void)
    {
        std::unique_lock<std::mutex> lock(m);
        while (q.empty())
        {
            // release lock as long as the wait and reaquire it afterwards.
            c.wait(lock);
        }
        T val = q.front();
        q.pop();
        return val;
    }
private:
    std::queue<T> q;
    mutable std::mutex m;
    std::condition_variable c;
};
#pragma once
#include "pch.h"
#include <string>

enum class UnitType {
	Warrior = 0,
	Spear,
	Archer,
	Wizard,
};

enum class WeaponType
{
	None = 0,
	Melee,
	Ranged,
	Magic
};

class Unit {
private:
	UnitType type;
	WeaponType weapon;
	SDL_Rect rect;
	SDL_Texture* texture;

	int hp = 50;
	//Speed is how many regular tiles it can travel per round/Tile slowness.
	int speed = 20;

	int constitution = 50;
	int range;
	float damage;

	float x=1;
	float y=2;

public:
	static constexpr int ConstMax = 50;
	Unit(UnitType type, int x, int y);
	std::string GetJson();
	void Draw(SDL_Rect dest);

	inline int GetX() const { return (int) (x+.5f); }
	inline int GetY() const { return (int) (y+.5f); }
	//These return the float positions.
	inline float GetXF() const { return x; }
	inline float GetYF() const { return y; }

	inline int GetSpeed() const { return speed; }
	inline void Move(int dx, int dy) {
		x = (float) dx; y = (float) dy;
	}
	//This is for animations, to partial move the character.
	inline void MoveF(float dx, float dy) {
		x = dx; y = dy;
	}

};#pragma once
#include "pch.h"
#include "map.h"
#include "unit.h"
#include "gameplayer.h"
#include "pathfind.h"

class ViewPort {
private:
	int topX=0, topY=0;
	int width=0, height=0;
	float zoom = 1.0f;
	//Camera Location
	double camX=0.0, camY=0.0;  
	double camTX=0.0, camTY=0.0;
public:
	ViewPort(int x, int y, int w, int h, float zoom);
	ViewPort() = default;
	
	void SetCamera(double& x, double& y);
	void Update(int ms);
	void Draw(Map& map, std::vector<GamePlayer> players, PathFinder *pathFinder);
	void DoSomething();
	bool GetCellAtMouseXY(int mx, int my, int& x, int& y);
	void RenderTextureAt(int cx, int cy, int ocx, int ocy, SDL_Texture* tex, SDL_Rect* sourceRect);
	bool MouseInViewPort(int x, int y);
	void DrawNumber(SDL_Rect location, int value);





};
