#include "pch.h"
#include "action.h"


bool ActionPlayLocal::Process(double time)
{
    return false;
}

void ActionPlayLocal::Click()
{
}

ActionMovePlayer::ActionMovePlayer(Unit& who, int x, int y): actor(who)
{
    tx = x;
    ty = y;
}

bool ActionMovePlayer::HasKeyboardControl()
{
    return false;
}

bool ActionMovePlayer::Process(double time)
{
    float dx = tx - actor.GetXF();
    float dy = ty - actor.GetYF();
    float len = sqrt(dx * dx + dy * dy);
    dx /= len; 
    dy /= len;
    actor.MoveF(actor.GetXF() + dx*(float)time*4.0f, actor.GetYF() + dy*(float)time*4.0f);
    //XXXC CRW - need to store old direction to see if we reversed - went too far, lag, etc.
    if (len < 0.05) {
        actor.Move(tx, ty);
        return true;
    }
    return false;
}

void ActionMovePlayer::Click()
{
}

void ActionMovePlayer::Draw()
{
    //we don't have to do anything here....
}

void Action::Mouse(int mx, int my, int b)
{
    //Do nothing.
}

Action::Action()
{
}
#include "pch.h"
#include "actionintro.h"
#include "assetmgr.h"
#include "SDL.h"
#include "game.h"
#include "actionselectserver.h"

ActionIntro::ActionIntro()
{
    //Assets are loaded, nothing to do...
}

bool ActionIntro::Process(double time)
{
    eTime += time;
    if ((eTime > showTime) || (clicked)) {
        int bp = 0;
        nextActions.push_back(new ActionSelectServer());
        return true;
    }
    return false;
}

void ActionIntro::Click()
{
    clicked = true;
}

void ActionIntro::Draw()
{
    int alpha = 255;

    if (eTime < 1) {
        alpha = (int((255) * eTime));
    }
    if (eTime > (showTime - 1)) {
        alpha = (int((255) * (showTime - eTime)));
    }

    SDL_Rect rect;
    SDL_Texture* img = AssetMgr::GetAll("INTRO", rect);
    int i = SDL_SetTextureAlphaMod(img, alpha);

    //GoodDoge found the line below
    i = SDL_SetTextureBlendMode(img, SDL_BLENDMODE_BLEND);

    int x = (Display::Width - 600) >> 1;
    int y = (Display::Height - 300) >> 1;
    SDL_Rect dest{ x,y,600,300 };
    SDL_SetRenderDrawBlendMode(Display::GetRenderer(), SDL_BLENDMODE_BLEND);
    Display::DrawTexture(img, &rect, &dest);
    SDL_SetRenderDrawBlendMode(Display::GetRenderer(), SDL_BLENDMODE_NONE);
}
#include "pch.h"
#include "actionjoincreate.h"
#include "assetmgr.h"
#include "display.h"
#include "label.h"
#include "textbox.h"
#include <functional>
#include "game.h"
#include "../3rd/jute.h"
#include "json.h"



using std::placeholders::_1;

ActionJoinCreate::ActionJoinCreate():
    //Fire up the callback message, no need to delete this way
    ourCallBack(std::bind(&ActionJoinCreate::MessageIn, this, _1))
{
    using namespace std::placeholders;
    location = SDL_Rect{
        (Display::Width - 600) >> 1,
        (Display::Height - 300) >> 1,
        600, 300 };

    SDL_Rect temp;
    SDL_Texture* bTex = AssetMgr::GetAll("BUTTON", temp);

    Label *lTitle = new Label(location.x, location.y+5, location.w, 20);
    lTitle->SetText("Join a current room or create a new one");

    Button* bJoin = new Button(location.x + 10, location.y + 30, 256, 48);
    bJoin->SetText("Join Room");
    bJoin->SetTexture(bTex);
    bJoin->SetOnClick(std::bind(&ActionJoinCreate::joinClick, this));

    tRoomCode = new TextBox(location.x + 300, location.y + 35, 256, 20);
    tRoomCode->SetText("");
    tRoomCode->SetMaxLength(4);
    tRoomCode->SetCaps(true);
    tRoomCode->SetLetters("abcdefghijklmnopqrstuvwxyz");


    Button* bCreate = new Button(location.x + 10, location.y + 90, 256, 48);
    bCreate->SetText("Create Room");
    bCreate->SetTexture(bTex);
    bCreate->SetOnClick(std::bind(&ActionJoinCreate::createClick, this));

    Button* bExit = new Button(location.x + 10, location.y + 150, 256, 48);
    bExit->SetText("Just Wander");
    bExit->SetTexture(bTex);
    bExit->SetOnClick(std::bind(&ActionJoinCreate::backClick, this));

    controls.push_back(lTitle);
    controls.push_back(bJoin);
    controls.push_back(tRoomCode);
    controls.push_back(bCreate);
    controls.push_back(bExit);

    mouseMan = new MouseManager(&controls);
    
    keyMan.SetCallBack(std::bind(&ActionJoinCreate::keyPressed,this, _1));
   
}

ActionJoinCreate::~ActionJoinCreate()
{
    for (auto i : controls) delete i;
    delete mouseMan;
}

bool ActionJoinCreate::Process(double time)
{
    //should ::Process() here
    int mx, my;
    uint32_t mouseState = SDL_GetMouseState(&mx, &my);
    for (auto c : controls) {
        c->Process(time);
    }

    mouseMan->Process(mx, my, mouseState);
    keyMan.Process(time);

    if (clicked) {
        int bp = 0;
        return true;
    }
  
    return false;
}

void ActionJoinCreate::Click()
{
}

void ActionJoinCreate::Mouse(int x, int y, int b)
{
}

void ActionJoinCreate::Draw()
{
    draw();
}

void ActionJoinCreate::joinClick()
{
}

void ActionJoinCreate::createClick()
{
    std::string st = "{" +
        Json::Jsonify("request", "create") + "," +
        Json::Jsonify("game", "chaos") +
        "}";
    Game::gameInstance->SendMessage(st);
}

void ActionJoinCreate::backClick()
{
    clicked = true;
}


void ActionJoinCreate::MessageIn(std::string val)
{
    try {
        jute::jValue v = jute::parser::parse(val);
        std::string resp = v["request"].as_string();
        if (resp == "create") {
            std::string roomCode = v["roomcode"].as_string();
            if (roomCode.length() == 4) {
                //Trigger game, send room code.
                Game::gameInstance->SetRoomCode(roomCode);
                std::string st =
                    "{" +
                    Json::Jsonify("request", "join") + "," +
                    Json::Jsonify("roomcode", roomCode) + "," +
                    Json::Jsonify("game", "chaos") + "}";
                Game::gameInstance->SendMessage(st);
            }
        }
    }
    catch (...) {
        //Failed......
    }
    int bp = 0;
}

void ActionJoinCreate::keyPressed(int val)
{
    tRoomCode->KeyIn(val);
}

void ActionJoinCreate::draw()
{
    SDL_Rect rect;
    SDL_Texture* img = AssetMgr::GetAll("MENUBKG", rect);
    int i = SDL_SetTextureAlphaMod(img, 0);
    int x = (Display::Width - 600) >> 1;
    int y = (Display::Height - 300) >> 1;
    SDL_Rect dest{ x,y,600,300 };

    Display::DrawTexture(img, &rect, &dest);
    for (auto c : controls) {
        c->Draw();
    }
    return;
}
/*
Author:
Charles Wood
7-2-2020
*/

#include "pch.h"
#include "actionselectserver.h"
#include "assetmgr.h"
#include "game.h"
#include "actionjoincreate.h"


ActionSelectServer::ActionSelectServer()
{
    location = SDL_Rect {
        (Display::Width - 600) >> 1,
        (Display::Height - 300) >> 1,
        600, 300};

    SDL_Rect temp;
    SDL_Texture* bTex = AssetMgr::GetAll("BUTTON",temp);

    Button *bRemote = new Button(location.x+10, location.y+20, 256, 48);
    bRemote->SetText("Remote:82");
    bRemote->SetTexture(bTex);
    bRemote->SetOnClick(std::bind(&ActionSelectServer::remoteClick,this));
    

    Button *bLocal = new Button(location.x+10, location.y+80, 256, 48);
    bLocal->SetText("127.0.0.1:82");
    bLocal->SetTexture(bTex);
    bLocal->SetOnClick(std::bind(&ActionSelectServer::localClick, this));

    Button* bExit = new Button(location.x + 10, location.y + 140, 256, 48);
    bExit->SetText("Quit");
    bExit->SetTexture(bTex);
    bExit->SetOnClick(std::bind(&ActionSelectServer::quitClick, this));

    controls.push_back(bRemote);
    controls.push_back(bLocal);
    controls.push_back(bExit);
    mouseMan = new MouseManager(&controls);
}

ActionSelectServer::~ActionSelectServer()
{
    for (auto i : controls) delete i;
    delete mouseMan;
}

bool ActionSelectServer::Process(double time)
{
    int mx, my;
    uint32_t mouseState = SDL_GetMouseState(&mx, &my);
    mouseMan->Process(mx, my, mouseState);

    eTime += time;
    if ((eTime > 30000) || (clicked)) {
        int bp = 0;
        return true;
    }
    return false;
}

void ActionSelectServer::Click()
{
    //clicked = true;
}

void ActionSelectServer::Mouse(int x, int y, int b)
{
}

void ActionSelectServer::Draw()
{
    SDL_Rect rect;
    SDL_Texture* img = AssetMgr::GetAll("MENUBKG", rect);
    int i = SDL_SetTextureAlphaMod(img, 0);
    int x = (Display::Width - 600) >> 1;
    int y = (Display::Height - 300) >> 1;
    SDL_Rect dest{ x,y,600,300 };
    Display::DrawTexture(img, &rect, &dest);
    for (auto c : controls) {
        c->Draw();
    }
    return;
}

void ActionSelectServer::localClick()
{
    
    Game::gameInstance->onSelectServerCallback("ws://127.0.0.1:82/chat");
    nextActions.push_back(new ActionJoinCreate());
    
    clicked = true;
}

void ActionSelectServer::remoteClick()
{
    
    Game::gameInstance->onSelectServerCallback("ws://71.56.75.25:82/chat");
    nextActions.push_back(new ActionJoinCreate());
    clicked = true;
}

void ActionSelectServer::quitClick()
{
    
    Game::gameInstance->onSelectServerCallback("QUIT");
    clicked = true;
}
#include "pch.h"
#include "animation.h"
#pragma once
#include "pch.h"
#include "assetmgr.h"


void AssetMgr::Destroy()
{
	for (auto i : AssetMgr::Images) SDL_DestroyTexture(i.second);
}

bool AssetMgr::Load(std::string filename, std::string nick)
{
	SDL_Texture* texture = IMG_LoadTexture(Display::GetRenderer(), filename.c_str());
	if (texture == nullptr) {
		std::cout << "Failed to load:" << filename << "\n";
	}
	Images[nick] = texture;
	return false;
}

SDL_Texture* AssetMgr::Get(std::string nick, int gridSizeX, int gridSizeY, int x, int y, SDL_Rect& dest) {
	SDL_Texture* tex = Images[nick];
	if (tex == nullptr) return tex;
	dest.x = gridSizeX * x;
	dest.y = gridSizeY * y;
	dest.w = gridSizeX;
	dest.h = gridSizeY;
	return tex;
}

SDL_Texture* AssetMgr::GetAll(std::string nick, SDL_Rect& dest)
{
	SDL_Texture* tex = Images[nick];
	Uint32 fmt;
	int acs;
	dest.x = 0;
	dest.y = 0;
	SDL_QueryTexture(tex, &fmt, &acs, &dest.w, &dest.h);
		
	return tex;
}


//Statics
std::map<std::string, SDL_Texture*> AssetMgr::Images;
/*
Author:
Charles Wood
7-2-2020
*/

#include "pch.h"
#include "button.h"
#include "display.h"
#include "assetmgr.h"
#include "font16.h"

Button::Button(int x, int y, int w, int h)
{
	location = SDL_Rect{ x,y,w,h };
}

void Button::SetText(std::string val)
{
	label = val;
}

void Button::SetTexture(SDL_Texture* tex)
{
	texture = tex;
}

void Button::SetOnClick(std::function<void(void)> func)
{
	onClick = func;
}

void Button::MouseIn()
{
	hover = true;
}

void Button::MouseOut()
{
	hover = false;
}

void Button::MouseDown(int mx, int my)
{
	down = true;
}

void Button::MouseUp()
{
	down = false;
}

void Button::DrawNumber(SDL_Rect ilocation, char c)
{
	c = toupper(c);
	int idx = -1;

	if (c >= '0' && c <= '9') {
		idx = (int)c - '0';
	}
	if (c >= 'A' && c <= 'Z') {
		idx = ((int)(c - 'A')) + 10;
	}
	if (idx == -1) return;
	SDL_Rect texRect;
	SDL_Texture* fontText = AssetMgr::Get("FONT16",16,16,idx, 0,texRect);
	Display::DrawTexture(fontText,   &texRect, &ilocation);
}


void Button::Draw()
{
	SDL_Rect source{ 0, 0, location.w, location.h };
	if (hover) {
		source.y = 48;
	}
	if (down) source.y = 96;
	Display::DrawTexture(texture, &source, &location);
	//Change 16 to font size later on.
	SDL_Rect topLeft = SDL_Rect{ location.x,location.y, 16,16 };
	int xs, ys;
	int labelL = Font16::TextLength(label);

	xs = (location.w - labelL) >> 1;
	ys = (location.h - 16) >> 1;
	topLeft.x += xs;
	topLeft.y += ys;
	Font16::DrawText(label, topLeft.x, topLeft.y);
}

void Button::MouseClick(int mx, int my)
{
	onClick();
}

void Button::Process(double ms)
{
}
#include "pch.h"
#include "console.h"
#include "assetmgr.h"
#include "font16.h"

ConsoleView::ConsoleView(int x, int y, int w, int h, int lines)
{
	window = SDL_Rect{ x, y, w, h };
	maxLines = lines;
}

void ConsoleView::AddLine(std::string text)
{
	data.push_back(text);
	if (data.size() > maxLines) {
		data.pop_front();
	}
}

void ConsoleView::Clear()
{
	data.clear();
}

void ConsoleView::DrawNumber(SDL_Rect location, char c)
{
	c = toupper(c);
	int idx = -1;

	if (c >= '0' && c <= '9') {
		idx = (int)c - '0';
	}
	if (c >= 'A' && c <= 'Z') {
		idx = ((int)(c - 'A')) + 10;
	}
	if (idx == -1) return;
	SDL_Rect texRect;
	SDL_Texture* fontText = AssetMgr::Get("FONT16", 16,16, idx, 0, texRect);
	Display::DrawTexture(fontText, &texRect, &location);
	
}
void ConsoleView::Draw()
{
	SDL_ClipRectSection myClip(window.x, window.y, window.w, window.h);
	//Change 16 to font size later on.
	SDL_Rect topLeft = SDL_Rect{ window.x,window.y, 16,16 };
	for (auto str : data) { 
		Font16::DrawText(str, topLeft.x, topLeft.y);
		
		
		/*
		for (char c : str) {
			DrawNumber(topLeft, c );
			topLeft.x += 16;
		}
		topLeft.x = window.x;*/

		topLeft.y += 16;

	}
}
#include "pch.h"
#include "display.h"

Display::Display(int width, int height)
	: window(nullptr), renderer(nullptr) 
{
	Display::Width = width;
	Display::Height = height;
	if (SDL_CreateWindowAndRenderer(width, height, 0, &window, &renderer) < 0)
	{
		std::cout << "Failed to create display: " << SDL_GetError() << "\n";
	}
}

Display::~Display()
{
	SDL_DestroyRenderer(renderer);
	SDL_DestroyWindow(window);

	delete displayInstance;
}

void Display::Create(int width, int height)
{
	displayInstance = new Display(width, height);
}

void Display::Clear(Uint8 r, Uint8 g, Uint8 b)
{
	SDL_SetRenderDrawColor(GetRenderer(), r, g, b, 255);
	SDL_RenderClear(GetRenderer());
}

void Display::Present()
{
	SDL_RenderPresent(GetRenderer());
}

void Display::DrawTexture(SDL_Texture* texture)
{
	SDL_RenderCopy(GetRenderer(), texture, nullptr, nullptr);
}

void Display::DrawTexture(SDL_Texture* texture, const SDL_Rect* targetRect)
{
	SDL_RenderCopy(GetRenderer(), texture, nullptr, targetRect);
}

void Display::DrawTexture(SDL_Texture* texture, const SDL_Rect* targetRect, const SDL_Rect* subTexture)
{
	SDL_RenderCopy(GetRenderer(), texture, targetRect, subTexture);
	
}

/*Static members*/
Display* Display::displayInstance;

int Display::Width = 0;
int Display::Height = 0;


SDL_ClipRectSection::SDL_ClipRectSection(int x, int y, int w, int h)
{
	SDL_RenderGetClipRect(Display::GetRenderer(), &oldRect);
	SDL_Rect clip= { x,y,w,h };
	SDL_RenderSetClipRect(Display::GetRenderer(), &clip);
}

SDL_ClipRectSection::~SDL_ClipRectSection()
{
	SDL_RenderSetClipRect(Display::GetRenderer(), &oldRect);
}
/*
Author:
Charles Wood
7-2-2020
*/

#include "pch.h"
#include "font16.h"
#include "assetmgr.h"

//Note, couldn't figure out how to make it static, but whatever for now.
int spacing[97] { 1,1,8,16,29,40,54,66,71,79,86,94,105,110,118,123,131,142,150,160,170,181,192,203,212,223,234,240,246,257,268,279,289,304,314,325,336,347,357,366,377,388,395,402,414,423,436,447,458,468,479,490,500,510,521,532,548,558,568,577,585,594,601,612,624,631,641,651,661,671,681,688,698,708,714,720,730,736,750,760,770,780,790,798,808,815,825,835,848,857,867,874,883,889,898,908,908 };

void Font16::DrawText(const std::string &str, int x, int y)
{
	for (char c : str) {
		x += DrawLetter(c,x,y);
	}
}

int Font16::TextLength(const std::string &str, int at)
{
	int idx = 0;
	int x=0;
	for (char c : str) {
		
		int idx = (int)c - 32;
		if (idx == 0) {
			x += 4;
		}
		else {
			x += spacing[idx + 1] - spacing[idx];
		}
		at--;
		if (at == 0) break;
	}
	return x;
}

int Font16::DrawLetter(char c, int x, int y) {
	int idx = (int)c;
	if (idx < 32) return 0;
	if (idx > 127) return 0;
	idx -= 32;
	if (idx == 0) return 4;
	SDL_Rect texRect;
	//Below can be optimized
	SDL_Texture* fontText = AssetMgr::GetAll("FONT16", texRect);
	//Pick out our location in the buffer for the string
	texRect.x = spacing[idx];
	texRect.w = spacing[idx + 1] - spacing[idx];
	texRect.y = 0;
	texRect.h = 16;
	SDL_Rect ilocation{ x,y,texRect.w,texRect.h };
	Display::DrawTexture(fontText, &texRect, &ilocation);
	return texRect.w;
}#include "pch.h"
#include "pch.h"
#include "game.h"
#include "assetmgr.h"
#include "viewport.h"
#include "actionintro.h"
#include <functional>
#include "keymanager.h"

//XXXC CRW Need an action for requesting new room, joining room, etc.

Game::Game() : running(true), console{ nullptr }
{
	socketQueue = nullptr;
}

void Game::handleMouse()
{
	int mx, my;
	uint32_t mouseState = SDL_GetMouseState(&mx, &my);
	//Update the hover locations
	viewPort.GetCellAtMouseXY(mx, my, mCellX, mCellY);
	bool tMouseDown = mouseState & SDL_BUTTON_LEFT;

	if (tMouseDown != mouseDown) {   //State changed.
		if (tMouseDown) {
			viewPort.GetCellAtMouseXY(mx, my, lastMouseCell.x, lastMouseCell.y);
		} else { //Upclick
			int imx, imy;
			viewPort.GetCellAtMouseXY(mx, my, imx, imy);
			if ((imx == lastMouseCell.x) && (imy == lastMouseCell.y)) {
				click();
				lastMouseCell.x = -1;
				lastMouseCell.y = -1;
			}
		}
		mouseDown = tMouseDown;
	}
}

void Game::click()
{
	if (actions.size() > 0) {
		actions[actions.size() - 1]->Click();
		return;
	}
	int sp, su;
	//Bail out, out of range click
	if ((lastMouseCell.x < 0) || (lastMouseCell.y < 0)) {
		return;
	}
	if ((lastMouseCell.x >=Map::Size) || (lastMouseCell.y >= Map::Size)) return;

	if (getCharacterAt(lastMouseCell.x, lastMouseCell.y, sp, su)) {
		//We have a character......
		int bp = 0;
		if (sp == curPlayer) {
			if (su != selUnit) {
				selectUnit(sp, su);
			};
		}
	}
	else {
		if (selUnit != -1) {
			if (pathFinder->GetRange(lastMouseCell.x, lastMouseCell.y) > -1) {
				//This should be a valid move.

				auto& thisUnit = players[curPlayer].GetUnit(selUnit);
				std::string msg = "Move to:";
				msg += std::to_string(lastMouseCell.x) + " ";
				msg += std::to_string(lastMouseCell.y) + " ";
				std::string test = "{\"request\":\"create\"}";
				//console->AddLine(msg);
				console->AddLine(msg);
				if (socketQueue) {
					socketQueue->Send(test);
				}
				auto thePath = pathFinder->GetPathTo(lastMouseCell.x, lastMouseCell.y);
				for (auto me : thePath) {
					addAction(new ActionMovePlayer(thisUnit, me.x, me.y));
				}
				//thisUnit.Move(lastMouseCell.x, lastMouseCell.y);
				int bp = 0;
			}
		}
		selUnit = -1;
		pathFinder->ResetMap();
	}
}

void Game::selectUnit(int sp, int su)
{
	int bp = 0;
	selUnit = su;
	pathFinder->DoUnitMaxDistanceTravel(players[curPlayer].GetUnit(selUnit),10);
}



bool Game::getCharacterAt(int cx, int cy, int& sPlayer, int& sUnit)
{
	int pnum = 0;
	int unum = 0;
	for (auto iplayer : players) {
		for (auto unit : iplayer.GetUnits()) {
			if ((unit.GetX() == cx) && (unit.GetY() == cy)) {
				sPlayer = pnum;
				sUnit = unum;
				return true;
			}
			unum++;
		}
		pnum++;
	}
	return false;
}

void Game::keyPressed(int val)
{
}

void Game::SendMessage(std::string st)
{
	socketQueue->Send(st);
}

void Game::AddCallBack(std::function<void(std::string)> callBack)
{
	callBacks = callBack;
}

void Game::RemoveCallBack()
{
	callBacks = nullptr;
}
void Game::SetRoomCode(const std::string& val)
{
	roomCode = val;
	console->AddLine("Joined Room:" + val);
}

void Game::onSelectServerCallback(std::string url)
{
	if (url == "QUIT") {
		running = false;
	}
	socketQueue = new SocketQueue(url);
	socketQueue->Start();
}

//This has to be static unless we want to pass 100K vars around.
//Each action, when it closes, adds an action.
void Game::addAction(Action* action, Action* ref)
{
	if (ref == nullptr) {
		gameInstance->actions.push_back(action);
	}/*
	else {
		for (int i = 0; i < gameInstance->actions.size(); i++) {
			if 
		}
		if (gameInstance->actions.find(ref) != gameInstance->end()) {
			//insert before 

		}
	}*/
}

//static
void Game::Create()
{
	gameInstance = new Game();
}

bool Game::keyDown(int val)
{
	if (keys.find(val) == keys.end()) {
		keys[val] = 0;
	}

	return keys[val] > 0;
}

void Game::HandleEvent(double ms) {
	// message processing loop
	SDL_Event event;
	int val;
	if (SDL_PollEvent(&event)) {

		switch (event.type) {

		case SDL_KEYDOWN:
			val = event.key.keysym.sym;
			if (keys.find(val) != keys.end()) {
				keys[val] = 0;
			}
			if (keys[val] == 0) {
				//This is where a key gets entered........
				const uint8_t* ks = SDL_GetKeyboardState(NULL);
				bool shift =
					((ks[SDL_SCANCODE_LSHIFT] > 0) || (ks[SDL_SCANCODE_RSHIFT]>0));
				KeyboardManager::KeyManager->AddKeyDown(val,shift);
			}
			keys[val] += ms;
			if (val == SDLK_BACKSPACE) {
				if (keys[val]> 0.50) ms = 0;
			}
			else {
				if (keys[val] > 0.25) ms = 0;
			}

			break;
		case SDL_KEYUP:
			if (keys[event.key.keysym.scancode == SDL_SCANCODE_LSHIFT]) {
			}

			val = event.key.keysym.sym;
			keys[val] = 0;
			break;
		case SDL_QUIT:
			{
				gameInstance->running = false;
			}
		default:
			break;
		}
	}
}
//static
void Game::ProcessEvents()
{
	Game::gameInstance->HandleEvent(0);
	
	if (gameInstance->socketQueue) {
		gameInstance->socketQueue->Process();


		//int sz = gameInstance->socketQueue->Avail();
		if (gameInstance->socketQueue->Avail()) {
			//The temp is for setting breakpoints
			std::string temp = gameInstance->socketQueue->Get();
			gameInstance->console->AddLine(temp);
			if (gameInstance->callBacks != nullptr) {
				//Call it..
				(gameInstance->callBacks)(temp);
			}
			std::cout << temp << std::endl;
			int bp = 0;
		}
	}
}

bool Game::Process(double deltaTime) {
	bool doKeyb = true;

	//std::cout << "Frame time: " << deltaTime << "\n";
	if (actions.size() > 0) {
		//We need the last Action/Current Action iterator, so we can delete later.
		auto location = (actions.end() - 1);
		auto action = *location;
		if (action->HasKeyboardControl()) {
			doKeyb = false;
		}
	}
	
	if (doKeyb) {
		
		const uint8_t* ks = SDL_GetKeyboardState(NULL);
		if (ks[SDL_SCANCODE_W] > 0) cy -= 0.001;
		if (ks[SDL_SCANCODE_S] > 0) cy += 0.001;
		if (ks[SDL_SCANCODE_A] > 0) cx -= 0.001;
		if (ks[SDL_SCANCODE_D] > 0) {
			cx += 0.001;
		}
	}
	viewPort.SetCamera(cx, cy);
	viewPort.Update(deltaTime);
	size_t size = actions.size();

	if (size > 0) {
		//We need the last Action/Current Action iterator, so we can delete later.
		auto location = (actions.end() - 1);
		//Now we have the action...
		Action* action = *location;
		bool resultClose = action->Process(deltaTime);
		if (resultClose) {
			//We have to delete the current one before we can add the new one(s) on top...
			std::list<Action*> tempActions = action->GetNext();
			actions.erase(location);
			if (tempActions.size() != 0) {
				for (auto a : tempActions) {
					addAction(a);
				}
			}
			//Must do this last.
			delete action;
		}
	}
	handleMouse();
	Draw(deltaTime);
	return running;
}

void Game::Draw(double deltaTime)
{
	SDL_Rect myRect;

	//Get the background up there.........
	SDL_Texture* tempTex = AssetMgr::GetAll("BKG", myRect);
	SDL_Rect screen = { 0,0,1600,800 };
	SDL_RenderSetClipRect(Display::GetRenderer(), &screen);
	Display::DrawTexture(tempTex, &myRect, &screen);
	
	//Draw the map
	viewPort.Draw(*gameMap, players, pathFinder);

	SDL_RenderSetClipRect(Display::GetRenderer(), &screen);
	//Do actions, if they need to draw....

	size_t size = actions.size();
	if (size > 0) {
		//We need the last Action/Current Action iterator, so we can delete later.
		auto location = (actions.end() - 1);
		//Now we have the action...
		Action* action = *location;
		action->Draw();
	}

	//No mouse during action time for now

	console->Draw();
	//Draw the UI......
}

void Game::StartUp(int x, int y)
{
	gameMap = new Map();
	gameMap->Generate();

	pathFinder = new PathFinder(*gameMap);
		
	//These numbers come from the background image........
	viewPort = ViewPort(325, 75, 1225, 675, 1.0f);
	console = new ConsoleView(16, 464, 272, 320, 18);
	console->AddLine("Starting");
	GamePlayer player;
	players.push_back(player);
	curPlayer = 0;
	selUnit = -1; //No unit;
	
	//Get our time setup properly.....
	now = SDL_GetPerformanceCounter();
	addAction(new ActionIntro());
}

void Game::NextPlayer()
{
	curPlayer++;
	curPlayer = curPlayer % players.size();
}

Game::~Game()
{
	delete socketQueue;
	delete console;
	delete gameInstance;
	
}

/*Static Members*/
Game* Game::gameInstance;

int Game::mCellX = 5;
int Game::mCellY = 5;
#include "pch.h"
#include "gameplayer.h"

GamePlayer::GamePlayer()
{
	for (int i = 0; i < initUnits; i++)
	{
		units.push_back(Unit(((UnitType)i), 10 + rand() % 12, 5 + rand() % 12));
	}
}

std::string GamePlayer::GetJson() {
	std::string result = "{";
	for (int i = 0; i < initUnits; i++)
	{
		result += units[i].GetJson();
		if (i < (initUnits - 1)) result += ",";
		result += "\n";
	}
	result += "}\n";
	return result;
}#include "pch.h"
#include "keymanager.h"

KeyboardManager::KeyboardManager()
{
	
}

void KeyboardManager::Process(double ms) {
    if (KeyManager == nullptr) {
        KeyManager = new KeyboardManager();
    }
    if (keyQueue.size() > 0) {
        int val = *(keyQueue.begin());
        keyQueue.pop_front();
        if (callBack) callBack(val);
    }
}

void KeyboardManager::SetCallBack(std::function<void(const int)> a)
{
   callBack = a;
}

void KeyboardManager::AddKeyDown(int key, bool shift)
{
    //Now we can add capital letters......
    if ((key >= 'a') && (key <= 'z') && shift) {
        key -= 32;
    }
    if (shift) {
        switch (key) {
            //number keys
        case '0': key = ')'; break;
        case '1': key = '!'; break;
        case '2': key = '@'; break;
        case '3': key = '#'; break;
        case '4': key = '$'; break;
        case '5': key = '%'; break;
        case '6': key = '^'; break;
        case '7': key = '&'; break;
        case '8': key = '*'; break;
        case '9': key = '('; break;
            //Other punctuation
        case '`': key = '~'; break;
        case '-': key = '_'; break;
        case '=': key = '+'; break;
        case '[': key = '{'; break;
        case ']': key = '}'; break;
        case ';': key = ':'; break;
        case '\'': key = '"'; break;
        case ',': key = '<'; break;
        case '.': key = '>'; break;
        case '/': key = '?'; break;
        }
    }
    keyQueue.push_back(key);
}

void KeyboardManager::SetShift(bool state)
{
    shiftState = state;
}


std::list<int> KeyboardManager::keyQueue;
KeyboardManager *KeyboardManager::KeyManager;
#include "pch.h"
#include "label.h"
#include "font16.h"

Label::Label(int x, int y, int w, int h)
{
	location = SDL_Rect{ x,y,w,h };
}

void Label::SetText(std::string val)
{
	label = val;
}

void Label::SetTexture(SDL_Texture* tex)
{
	//nothing, unless we want a background......
}

void Label::SetOnClick(std::function<void(void)> func)
{
	//we don't do this.
}

void Label::MouseIn()
{
}

void Label::MouseOut()
{
}

void Label::MouseDown(int mx, int my)
{
}

void Label::MouseUp()
{
}

void Label::Draw()
{
	//center our location, and just draw it.....
	int labelL = Font16::TextLength(label);
	int xs = (location.w - labelL) >> 1;
	int ys = (location.h - 16) >> 1;
	xs += location.x;
	ys += location.y;
	Font16::DrawText(label, xs, ys);
}

void Label::MouseClick(int mx, int my)
{
}

void Label::Process(double ms)
{
}
#include "pch.h"
#include "display.h"
#include "game.h"
#include "perlinmap.h"
#include <SDL_image.h>
#include "assetmgr.h"
#include "map.h"
#include "viewport.h"
#include "../3rd/easywsclient.hpp"

#include <assert.h>
#include <stdio.h>
#include <string>
#include <memory>
#include "unit.h"
#include "../3rd/jute.h"




int main(int argc, char* argv[])
{
	if (SDL_Init(SDL_INIT_EVERYTHING) != 0)
	{
		std::cout << "Failed to init SDL " << SDL_GetError() << "\n";
		return -1;
	}

	Display::Create(1600, 800);
	IMG_Init(IMG_INIT_PNG);

	//Get our stuff loaded up
	AssetMgr::Load("assets/landscape.png", "LAND");
	AssetMgr::Load("assets/background.png", "BKG");
	AssetMgr::Load("assets/Dudes.png", "UNITS");
	AssetMgr::Load("assets/highlights.png", "HIGHLIGHT");
	AssetMgr::Load("assets/font16.png", "FONT16");
	AssetMgr::Load("assets/intro.png", "INTRO");
	AssetMgr::Load("assets/menubkg.png", "MENUBKG");
	AssetMgr::Load("assets/button.png", "BUTTON");

	Game::Create();
	Game::gameInstance->StartUp(1600, 800);

	Uint64 now, last;
	now = SDL_GetPerformanceCounter();

	while (Game::IsRunning())
	{
		//Handle our timing
		last = now;
		now = SDL_GetPerformanceCounter();
		double deltaTime = (double)((now - last) / (double)SDL_GetPerformanceFrequency());

		Game::ProcessEvents();
        if (!Game::gameInstance->Process(deltaTime)) break;
		Game::gameInstance->Draw(deltaTime);
		Display::Present();
		SDL_Delay(1);
	}
	AssetMgr::Destroy();
	SDL_Quit();
	return 0;
}
#include "pch.h"
#include "map.h"
#include "perlinmap.h"

Map::Map()
{

}

void Map::Generate()
{
	PerlinMap noise(Size,Size);
	noise.Randomize(400004);
	noise.MakePerlin();
	noise.Normalize();

	for (int y = 0; y < Size; y++) {
		for (int x = 0; x < Size; x++) {
			int val =noise.GetTerrain(x, y, 9);
			
			map[y][x] = MapTile(val);
		}
	}

}

int Map::get(int x, int y)
{

	int val = map[y][x].GetTestCellVal();
	return val;
	
}

MapTile& Map::Get(int x, int y)
{
	if (x < 0) x = 0;
	if (y < 0) y = 0;
	if (x >= Map::Size) x = Map::Size - 1;
	if (y >= Map::Size) y = Map::Size - 1;
	return map[x][y];
}

#include "pch.h"
#include "maptile.h"
#include "assetmgr.h"
#include "map.h"
#include "unit.h"
#include "gameplayer.h"

int MapTile::getSpeed()
{

	switch (type) {
	case MapCellType::MARSH: return 3;
	case MapCellType::GRASS: return 1;
	case MapCellType::STEPPE: return 2;
	case MapCellType::HILL: return 7;
	case MapCellType::ROCKY: return 14;
	case MapCellType::DESTROYED: return 3;
	}
	//Impassable land...
	return 255;
}

MapTile::MapTile()
{

}

//Will have to figure out how to make it prettier
MapTile::MapTile(int val)
{
	imgOffset = rand() % 8;
	type = (MapCellType) val;
	speed = getSpeed();
}

MapTile::MapTile(MapCellType type)
{
	//this will work for now.....
	imgOffset = rand() % 8;
	this->type = type;
	speed = getSpeed();
}

void MapTile::Draw(SDL_Rect dest)
{
	SDL_Rect myRect;
	SDL_Texture* tempTex = AssetMgr::Get("LAND", Map::TileSize, Map::TileSize, imgOffset,(int) type, myRect);
	Display::DrawTexture(tempTex, &myRect, &dest);
	if (selected) {
		SDL_Texture* highlightTex = AssetMgr::Get("HIGHLIGHT", Map::TileSize, Map::TileSize, 0, 0, myRect);
		Display::DrawTexture(highlightTex, &myRect, &dest);

		//SDL_Texture* dude = AssetMgr::Get("UNITS", Map::TileSize, 0, 2, myRect);
		//Display::DrawTexture(dude, &myRect, &dest);
		
		//Unit dude(UnitType::Warrior);
		//dude.Draw(dest);

		GamePlayer myPlayer;
		myPlayer.GetUnits();
		
	}
}
#include "pch.h"
#include "mousemanager.h"


MouseManager::MouseManager(std::vector<VisBase*>* items)
{
    viewItems = items;
}

void MouseManager::Process(int mx, int my, int mb)
{
    VisBase* found = nullptr;
    SDL_Point pt{ mx,my };
    for (auto visBase : *viewItems) {
        if (SDL_PointInRect(&pt, &visBase->location)) {
            found = visBase;
        }
    }
    if (found != lastHover) {
        if (lastHover) {
            lastHover->MouseOut();
            lastHover->MouseUp();
            lastDown = nullptr;
        }
        if (found) {
            found->MouseIn();
        }
        lastHover = found;
    }
    if (lastHover != nullptr) {
        if (mouseDown != mb) {
            if (mb == 1) {
                lastHover->MouseDown(mx,my);
                lastDown = lastHover;
            }
            else {
                lastHover->MouseUp();
                if (lastDown == lastHover) lastHover->MouseClick(mx, my);
            }
        }
        mouseDown = mb;
    }
}

MouseManager::~MouseManager()
{
    if (viewItems) delete viewItems;
}
#include "pch.h"
#include "pathfind.h"
#include <set>
#include <algorithm>
#include <random>


PathFinder::PathFinder(Map& imap) : map(imap)
{
	dRange = new std::array<std::array<int, Map::Size>, Map::Size>();
}

void PathFinder::DoUnitMaxDistanceTravel(const Unit& who, int val)
{
	ResetMap();
	calcFlood(who.GetX(),who.GetY(),who.GetSpeed());
}

void PathFinder::DoUnitMaxDistanceAttack(const Unit& who, int val, bool aerial)
{

}

int PathFinder::GetRange(int x, int y)
{
	//Keep it in range.
	if (x < 0) x = 0;
	if (y < 0) y = 0;
	if (x >= Map::Size) x = Map::Size - 1;
	if (y >= Map::Size) y = Map::Size - 1;
	return (*dRange)[y][x];
}

void PathFinder::ResetMap()
{
	for (int y = 0; y < Map::Size; y++) {
		for (int x = 0; x < Map::Size; x++) {
			(*dRange)[y][x] = -1;
		}
	}
}

PathFinder::xyRange PathFinder::pathGood(int x, int y)
{
	int d = Map::Size * 2 + 1;
	if (((x >= 0) && (x < Map::Size)) && ((y >= 0) && (y < Map::Size))) {
		d = ((*dRange)[y][x]);
	}
	if (d < 0) d = Map::Size*2+1;
	return xyRange{ x,y,d };
}

/// <summary>
/// Get path to starts at x, y, and ends at pathfinder 0.  
/// This shall not be called if a path is not already possible.
/// </summary>
/// <param name="x">target x cell</param>
/// <param name="y">target y cell</param>
/// <returns></returns>
std::vector<SDL_Point> PathFinder::GetPathTo(int x, int y)
{
	int sx = x;
	int sy = y;
	typedef std::tuple<int, int, int> xyRange;
	std::vector<xyRange> found;

	std::vector<SDL_Point> thePath;
	//This is our starting location.
	
	thePath.push_back(SDL_Point{ x,y });

	//It's zero when we find the target
	while ((*dRange)[y][x] > 1)
	{
		int d = (*dRange)[y][x];
		found.push_back(pathGood(x, y - 1));
		found.push_back(pathGood(x, y + 1));
		found.push_back(pathGood(x - 1, y));
		found.push_back(pathGood(x + 1, y));

		std::sort(found.begin(), found.end() , 
			[](xyRange& a, xyRange& b) {
				return std::get<2>(a) < std::get<2>(b);
			}
			);

		//This gives us a little randomness in motion so they don't walk straight lines.

		int idx = 0;
		if (std::get<2>(found[0]) == std::get<2>(found[1])) {
			idx = rand() % 2;
		}

		//Note, we set d here
		std::tie(x, y, d) = found[idx];
		found.clear();

		thePath.push_back( SDL_Point{ x,y });
		if (thePath.size() > 20) {
			int breakPoint = 0;
		}
	}
	return thePath;
}

bool PathFinder::rangeOpen(int x, int y, int& speed)
{
	speed = 255;
	if (x < 0) return false;
	if (y < 0) return false;
	if (x >= Map::Size) return false;
	if (y >= Map::Size) return false;
	speed = map.Get(x, y).GetSpeed();
	if (speed < 99) {
		int breakPoint = 0;
	}

	if (((*dRange)[y][x]) == -1) return true;
	return false;
}

void PathFinder::calcFlood(int x, int y, int maxSpeed)
{
	typedef std::tuple<int, int, int> xyRange;
	std::set<xyRange> found;
	found.insert(xyRange(x, y, 1));
	int speed = 0;
	while (found.size() > 0)
	{
		std::set<xyRange> mainSet;
		int sx, sy, d;
		for (xyRange xyz : found) {
			std::tie(sx, sy, d) = xyz;
			//Set this spot.
			(*dRange)[sy][sx] = d;
			if (rangeOpen(sx, sy - 1, speed)) mainSet.insert(xyRange(sx, sy - 1, d + speed));
			if (rangeOpen(sx, sy + 1, speed)) mainSet.insert(xyRange(sx, sy + 1, d + speed));
			if (rangeOpen(sx + 1, sy, speed)) mainSet.insert(xyRange(sx + 1, sy, d + speed));
			if (rangeOpen(sx - 1, sy, speed)) mainSet.insert(xyRange(sx - 1, sy, d + speed));
		}
		found.clear();
		for (xyRange xy : mainSet) {
			std::tie(sx, sy, d) = xy;
			bool isFound = false;
			//Figure out if that position is already found, we don't want to search 2-20x.
			//double searching makes bad paths.
			for (auto position : found) {
				int isx, isy, isd;
				std::tie(isx, isy, isd) = position;
				if ((sx == isx) && (sy == isy)) {
					isFound = true;
					break;
				}
			} //Back from break above
			if (!isFound) {
				//Check our max speed now
				if (d <= maxSpeed) {
					found.insert(xy);
				}
			}
			else {
				int bp = 0;
			}
		}
		mainSet.clear();
	}
}

PathFinder::~PathFinder()
{
	delete dRange;
}#include "pch.h"#pragma once
#include "pch.h"
#include "perlinmap.h"
#include <random>
#include "display.h"

PerlinMap::PerlinMap(int x, int y)
{
	width = x;
	height = y;

	evalues = new float[(size_t)x * y];
	svalues = new float[(size_t)x * y];
}

PerlinMap::~PerlinMap()
{
    if (svalues) delete[] svalues;
    if (evalues) delete[] evalues;
}

void PerlinMap::MakePerlin()
{
	float fbias = 2.0f;
	for (int x = 0; x < width; x++) {
		for (int y = 0; y < height; y++)
		{
			float fNoise = 0.0f;
			float fScaleAcc = 0.0f;
			float fScale = 1.0f;

			for (int o = 0; o < (octaves-1); o++)
			{
				int nPitch = width >> o;
				int nSampleX1 = (x / nPitch) * nPitch;
				int nSampleY1 = (y / nPitch) * nPitch;

				int nSampleX2 = (nSampleX1 + nPitch) % width;
				int nSampleY2 = (nSampleY1 + nPitch) % width;

				float fBlendX = (float)(x - nSampleX1) / (float)nPitch;
				float fBlendY = (float)(y - nSampleY1) / (float)nPitch;

				float fSampleT = (1.0f - fBlendX) * svalues[nSampleY1 * width + nSampleX1] + fBlendX * svalues[nSampleY1 * width + nSampleX2];
				float fSampleB = (1.0f - fBlendX) * svalues[nSampleY2 * width + nSampleX1] + fBlendX * svalues[nSampleY2 * width + nSampleX2];

				fScaleAcc += fScale;
				fNoise += (fBlendY * (fSampleB - fSampleT) + fSampleT) * fScale;
				fScale = fScale / fbias;
			}
			// Scale it
			evalues[y * width + x] = fNoise / fScaleAcc;
		}
	}
}

void PerlinMap::Normalize()
{
	float max = -100.0f;
	float min = 100.0f;
	for (int i = 0; i < (width * height); i++) {
		if (evalues[i] > max) max = evalues[i];
		if (evalues[i] < min) min = evalues[i];
	}
	float diff = max - min;
	float mult = 1 / diff;
	for (int i = 0; i < (width * height); i++) {
		evalues[i] -= min;
		evalues[i] *= mult;
	}
}



int PerlinMap::GetTerrain(int x, int y, int max)
{
	//Scale to requested level
	int val = (int)(evalues[y * width + x] * max);

	if (val < 0) val = 0;
	if (val >= max) val = max - 1;
	return val;
}

//static
void PerlinMap::TestDraw()
{
	/*
	int w = 512;
	int h = 512;
	int rval = rand() % 500;
	PerlinMap map = PerlinMap(w, h);
	map.Randomize(107);
	map.MakePerlin();
	map.Normalize();
	SDL_Renderer* ren = Display::GetRenderer();
	//now to draw it.........   ugh
	for (int y = 0; y < h; y++) {
		for (int x = 0; x < w; x++) {
			int val = map.GetTerrain(x, y, 8) * 32;
			if (val > 255) val = 255;
			if (val < 0) val = 0;
			SDL_SetRenderDrawColor(ren, val, val, val, 255);
			SDL_RenderDrawPoint(ren, x, y);
		}
	}
	*/
}

void PerlinMap::Randomize(int iseed)
{
    std::mt19937 gen(iseed);
    std::uniform_real_distribution<> dis(0.0, 1.0);
    for (int x = 0; x < width; x++) {
        for (int y = 0; y < height; y++) {
            svalues[y * width + x] = (float) dis(gen);
        }
    }
}

#include "pch.h"
#include "socketcallback.h"

MessageCallBack::MessageCallBack(std::function<void(std::string)> iCallBack):callBack(iCallBack)
{
	Game::gameInstance->AddCallBack(callBack);
}

MessageCallBack::~MessageCallBack()
{
	Game::gameInstance->RemoveCallBack();
}
#include "pch.h"
#include "socketqueue.h"
#include "../3rd/easywsclient.hpp"

/* Ugly Windows code.....*/

#ifdef _WIN32
#pragma comment( lib, "ws2_32" )
#include <WinSock2.h>
#endif

SocketQueue::SocketQueue(std::string url)
{
    this->url = url;
	instance = this;
}

bool SocketQueue::Send(std::string val)
{
    qOut.Enqueue(val);
    return true;
}

bool SocketQueue::Avail()
{
    return (qIn.Size() > 0);
}

std::string SocketQueue::Get()
{
    return qIn.Dequeue();
}

bool SocketQueue::Start()
{
    using easywsclient::WebSocket;
    //More ugly Windows code.
#ifdef _WIN32
    INT rc;
    WSADATA wsaData;
    rc = WSAStartup(MAKEWORD(2, 2), &wsaData);
    if (rc) {
        printf("WSAStartup Failed.\n");
        return true;
    }
#endif
    ws = std::unique_ptr<WebSocket>(WebSocket::from_url(url));
    return true;
}

void SocketQueue::Process()
{
    using easywsclient::WebSocket;
    if (ws) {
        if (ws->getReadyState() != WebSocket::CLOSED) {
            WebSocket::pointer wsp = &*ws; // <-- because a unique_ptr cannot be copied into a lambda
            
            //Send if there is something to send.
            if (SocketQueue::instance->qOut.Size() > 0) {
                ws->send(qOut.Dequeue());
            }
            ws->poll();
            ws->dispatch([wsp](const std::string& message) {
                printf(">>> %s\n", message.c_str());
                SocketQueue::instance->qIn.Enqueue(message);
                //we got a message, lets reply with status
                //std::string wtf = p.GetJson();
                //wsp->send(wtf);
                });
        }
        else {
            Stop();
        }
    }
}

void SocketQueue::Stop()
{
#ifdef _WIN32
    WSACleanup();  //More Windows slop
#endif
    //This is to notify the game that the socket died.
    SocketQueue::instance->qIn.Enqueue("{\"socket\":\"closed\"}");
    // N.B. - unique_ptr will free the WebSocket instance upon return:
}

//statics
SocketQueue* SocketQueue::instance = nullptr;

#include "pch.h"
#include "textbox.h"
#include "display.h"
#include "font16.h" 

TextBox::TextBox(int x, int y, int w, int h)
{
	location = SDL_Rect{ x,y,w,h };
}

void TextBox::SetText(std::string val)
{
	label = val;
}

std::string TextBox::GetText()
{
	return std::string();
}

void TextBox::SetTexture(SDL_Texture* tex)
{
}

void TextBox::SetOnClick(std::function<void(void)> func)
{
}

void TextBox::MouseIn()
{
}

void TextBox::MouseOut()
{
}

void TextBox::MouseDown(int mx, int my)
{
}


void TextBox::MouseUp()
{
}

void TextBox::Draw()
{
	//we need a black box
	SDL_SetRenderDrawColor(Display::GetRenderer(), 0, 0, 0, 255);
	SDL_RenderFillRect(Display::GetRenderer(), &location);

	//We need a border
	SDL_SetRenderDrawColor(Display::GetRenderer(), 255, 255, 255, 255);
	SDL_RenderDrawRect(Display::GetRenderer(), &location);

	Font16::DrawText(label,location.x + 2, location.y + 2);

	
	if (showCursor) {
		//Got figure out where the cursor is.....
		int curOffset = 0;
		if (curX > 0) {
			//std::string x = label.substr(0, curX);
			curOffset = Font16::TextLength(label,curX);
		}
		SDL_Rect cursor{ location.x + 2 + curOffset, location.y + 2, 1, location.h - 4 };
		SDL_RenderDrawRect(Display::GetRenderer(), &cursor);
	}

	std::map<char, int> vals;
	if (vals.find('c') != vals.end()) {}
	
}

void TextBox::MouseClick(int mx, int my)
{
}

void TextBox::Process(double ms)
{
	curTime += ms;
	if (curTime > 0.25) {
		curTime = 0;
		showCursor = !showCursor;
	}
}

void TextBox::KeyIn(int key)
{
	if (allowedChars.length() > 0) {
		if (allowedChars.find(key) <0) return;
	}

	//so cursor is at zero.....
	//therefore insert at zero, then increment the cursor
	if (key == SDLK_BACKSPACE) {
		if (curX > 0) {
			curX--;
			label.erase(label.begin() + curX);
		}
	}
	if (key == SDLK_DELETE) {
		try {
			label.erase(label.begin() + curX);
		} catch (...) {
		}
	}
	if (key == SDLK_LEFT) {
		if (curX > 0) {
			curX--;
		}
	}

	if (key == SDLK_END) {
		curX = (int)label.size();
	}
	if (key == SDLK_HOME) {
		curX = 0;
	}
	//Have to rearrange for those that add letters or move cursor
	if (!(curX < maxLen)) {
		//xxxc crw maybe beep here....
		return;
	}
	if (key == SDLK_RIGHT) {
		if (curX < (label.size() )) {
			curX++;
		}
	}
	if (label.length() >= maxLen) {
		//xxxc crw should beep here......
		return;
	}
	if ((key >= 32) && (key < 127)) {
		if (allCaps) key = static_cast<char>(std::toupper(key));
		label.insert(label.begin() + curX, (char)key);
		curX++;
	}

}
#include "pch.h"
#include "unit.h"
#include "map.h"
#include "display.h"
#include "assetmgr.h"
#include "json.h"

Unit::Unit(UnitType type, int x, int y)
{
	this->type = type;

	this->x = (float) x;
	this->y = (float) y;

	texture = AssetMgr::Get("UNITS", Map::TileSize, Map::TileSize, 0, (int)type, rect);

	weapon = WeaponType::None;
	hp = 0;
	speed = 0;
	range = 0;
	damage = 0.0f;

	//Weapon type and stats depend on unit type.
	switch (type)
	{
	case UnitType::Warrior:
		weapon = WeaponType::Melee;
		hp = 100;
		speed = 12;
		range = 1;
		damage = 20.0f;
		break;

	case UnitType::Spear:
		weapon = WeaponType::Melee;
		hp = 100;
		speed = 24;
		range = 1;
		damage = 35.0f;
		break;

	case UnitType::Archer:
		weapon = WeaponType::Ranged;
		hp = 100;
		speed = 30;
		range = 5;
		damage = 20.0f;
		break;

	case UnitType::Wizard:
		weapon = WeaponType::Magic;
		hp = 100;
		speed = 20;
		range = 2;
		damage = 40.0f;
		break;
	}
}


std::string Unit::GetJson()
{
	std::string result = "{\r\n";
	result += Json::Jsonify("hp", hp);
	result += ",\r\n";
	result += Json::Jsonify("x", GetX());
	result += ",\r\n";
	result += Json::Jsonify("y", GetY());
	result += "\r\n";
	result += "}\r\n";
	return result;
}

void Unit::Draw(SDL_Rect dest)
{
	Display::DrawTexture(texture, &rect, &dest);
}
#include "pch.h"
#include "viewport.h"
#include "assetmgr.h"
#include "game.h"
#include "font16.h"

bool cellDistanceShow = false;

ViewPort::ViewPort(int x, int y, int w, int h, float zoom)
{
	topX = x; topY = y; width = w; height = h;
	zoom = 1.0f;
	camTX = 0;
	camTY = 0;
	camX = 0;
	camY = 0;
}

void ViewPort::SetCamera(double &x, double &y)
{
	//Need some limits on this.....
	if (x < 0) x = 0;
	if (y < 0) y = 0;

	//So, whats our Max CamX
	double maxCamX = 1.0;
	double maxX = (double) (Map::Size * Map::TileSize);
	maxCamX = (maxX - width) / maxX;

	double maxCamY = 1.0;
	double maxY = (double)(Map::Size * Map::TileSize);
	maxCamY = (maxY - height) / maxY;





	if (y >= maxCamY) y = maxCamY;
	if (x >= maxCamX) x = maxCamX;

	camTX = x;
	camTY = y;
}


void ViewPort::Update(int ms)
{
	double delay = 9.0f;
	camX = ((camX*delay + camTX) / (delay+1.0));
	camY = ((camY*delay + camTY) / (delay+1.0));
}

int asdf = 0;
void ViewPort::Draw(Map& map, std::vector<GamePlayer> players, PathFinder *pathFinder)
{
	SDL_ClipRectSection myClip(topX, topY, width, height);
	SDL_Rect destRect;
	destRect.w = Map::TileSize;
	destRect.h = Map::TileSize;
	int maxXCells = width / destRect.w;
	int maxYCells = height / destRect.h;
	
	//Camera X/Y in cell grid location
	int cx = (int)(camX * Map::Size );
	int cy = (int)(camY * Map::Size );

	//Camera X/Y in pixel location
	int MScx = (int)(camX * Map::Size * Map::TileSize);
	int MScy = (int)(camY * Map::Size * Map::TileSize);
	
	//Cell grid offset from 0,0 of each cell
	int pcx = MScx % (Map::TileSize);
	int pcy = MScy % (Map::TileSize);
	
	if (cx < 0) cx = 0;
	if (cy < 0) cy = 0;
	
	int maxXCam = Map::Size - (width / Map::TileSize) -1;
	int maxYCam = Map::Size - (height / Map::TileSize) -1;

	if (cx > (maxXCam)) cx = maxXCam;
	if (cy > (maxYCam)) cy = maxYCam;
	
	for (int y = 0; y < maxYCells+2 /* scale*/; y++) {
		for (int x = 0; x < maxXCells+1/*scale*/; x++) {
			destRect.x = x * Map::TileSize + topX -pcx;
			destRect.y = y * Map::TileSize + topY -pcy;
			map.Get(cx + x, cy + y).Draw(destRect);

			//Now we need to handle the cells in the pathfinder.....
			if (pathFinder->GetRange(cx + x, cy + y) > 0) {
				SDL_Rect myRect;
				SDL_Texture* highlightTex = AssetMgr::Get("HIGHLIGHT", Map::TileSize, Map::TileSize, 0, 2, myRect);
				Display::DrawTexture(highlightTex, &myRect, &destRect);

				//This is for testing only....
				if (cellDistanceShow) {
					DrawNumber(destRect, pathFinder->GetRange(cx + x, cy + y));
				}
			}
			//Highlight Current Cell under the mouse.........
			if ((Game::mCellX == (cx + x)) && ((Game::mCellY == cy + y))) {
				SDL_Rect myRect;
				SDL_Texture* highlightTex = AssetMgr::Get("HIGHLIGHT", Map::TileSize, Map::TileSize, 0, 0, myRect);
				Display::DrawTexture(highlightTex, &myRect, &destRect);
			}
		}
	}

	for (auto& player : players)
	{
		for (auto unit : player.GetUnits())
		{
			destRect.x =(int) ((unit.GetXF()-(float)cx ) * (float)Map::TileSize + (float)topX - (float)pcx);
			destRect.y =(int) ((unit.GetYF()-(float)cy ) * (float)Map::TileSize + (float)topY - (float)pcy);
			unit.Draw(destRect);
		}
	}
}

void ViewPort::DoSomething()
{
	///some code......................
}
/// <summary>
/// 
/// </summary>
/// <param name="mx">Mouse x</param>
/// <param name="my">Mouse y</param>
/// <param name="x">Ref OUT cell x</param>
/// <param name="y">Ref OUT cell y</param>
/// <returns>Cell location in map of map cell under cursor.....</returns>
bool ViewPort::GetCellAtMouseXY(int mx, int my, int& x, int& y)
{
	
	mx -= topX;
	my -= topY;

	mx = (int)(Map::Size*Map::TileSize * camX + mx) / Map::TileSize;
	my = (int)(Map::Size*Map::TileSize * camY + my) / Map::TileSize;

	if (camX > .1) {
		int bp = 0;
	}

	x = mx;
	y = my;

	return false;
}

void ViewPort::RenderTextureAt(int cx, int cy, int ocx, int ocy, SDL_Texture* tex, SDL_Rect* sourceRect)
{
	return;
}

bool ViewPort::MouseInViewPort(int x, int y)
{
	if (x < topX) return false;
	if (y < topY) return false;
	if (x >= (topX + width)) return false;
	if (y >= (topY + height)) return false;
	return true;
}

void ViewPort::DrawNumber(SDL_Rect location, int value)
{
	std::string str = std::to_string(value);
	Font16::DrawText(str, location.x, location.y);
}
#pragma once
#include "pch.h"
#include "unit.h"

class Action {
public:
	//Returns true if Process is complete.
	virtual bool Process(double time) = 0;
	virtual void Draw() = 0;
	virtual void Click() = 0;
	virtual void Mouse(int mx, int my, int b);
	inline std::list<Action*> GetNext() { return nextActions; }
	virtual inline bool HasKeyboardControl() { return true; };
	Action();
protected: 

	std::list<Action*> nextActions;
private:
	

};

class ActionPlayLocal : public Action {
	bool Process(double time);
	void Click();
};


class ActionMovePlayer : public Action {
public:
	ActionMovePlayer(Unit& who, int x, int y);
	bool HasKeyboardControl() override;
	bool Process(double time);
	void Click();
	void Draw() override;
private:
	int tx, ty;
	Unit& actor;
};


//XXXC CRW  Need action request, action join, action waiting, action playing and action 
//game over.  Also have to do point inserts on action lists.
#pragma once
#include "action.h"

class ActionIntro : public Action {
public:
	ActionIntro();
	bool Process(double time);
	void Click();
	void Draw();
private:
	const int showTime = 4;  //seconds
	bool clicked = false;
	SDL_Texture* tex = nullptr;
	double eTime = 0;
};
/*
Author:
Charles Wood
7-3-2020
*/

#pragma once
#include "action.h"
#include "button.h"
#include "mousemanager.h"
#include "keymanager.h"
#include "textbox.h"
#include "socketcallback.h"

class ActionJoinCreate : public Action {
public:
	ActionJoinCreate();
	~ActionJoinCreate();
	bool Process(double time);
	void Click();
	void Mouse(int x, int y, int b) override;
	void Draw();

protected:
	void joinClick();
	void createClick();
	void backClick();
private:
	MessageCallBack ourCallBack;
	void MessageIn(std::string val);
	void keyPressed(int val);
	TextBox* tRoomCode = nullptr;
	MouseManager* mouseMan = nullptr;
	KeyboardManager keyMan;
	SDL_Rect location{ 0 };
	std::vector<VisBase*> controls;
	std::string serverUrl = "";
	bool clicked = false;
	double eTime = 0;
	void draw();
};





#pragma once
/*
Author:
Charles Wood
7-2-2020
*/

#pragma once
#include "action.h"
#include "button.h"
#include "mousemanager.h"

class ActionSelectServer : public Action {
public:
	ActionSelectServer();
	~ActionSelectServer();
	bool Process(double time);
	void Click();
	void Mouse(int x, int y, int b) override;
	void Draw() override;
protected:
	//event handlers
	void localClick();
	void remoteClick();
	void quitClick();
private:
	MouseManager* mouseMan = nullptr;
	SDL_Rect location{ 0 };
	std::vector<VisBase*> controls;
	std::string serverUrl = "";
	bool clicked = false;
	double eTime = 0;
};

#pragma once

class Animation
{
private:

public:
	virtual ~Animation() = default;

	virtual void Start() = 0;
};

class AnimationArrow : public Animation
{
private:
public:
};#pragma once
#include "pch.h"
#include "display.h"
#include "SDL_image.h"

class AssetMgr {
private:
	
	
	
public:
	static void Destroy();
	static std::map<std::string, SDL_Texture*> Images;
	static bool Load(std::string filename, std::string nick);
	static SDL_Texture* Get(std::string nick, int gridSizeX, int GridSizeY, int x, int y, SDL_Rect& dest);
	static SDL_Texture* GetAll(std::string nick, SDL_Rect& dest);
};

/*
Author:
Charles Wood
7-2-2020
*/
#pragma once
#include "pch.h"
#include <functional>
#include "visualbase.h"

class Button : public VisBase {
public:
	Button(int x, int y, int w, int h);
	void SetText(std::string val);
	void SetTexture(SDL_Texture* tex);
	void SetOnClick(std::function<void(void)> func);
	void MouseIn() override;
	void MouseOut() override;
	void MouseDown(int mx, int my) override;
	void MouseUp() override;
	void Draw() override;
	void MouseClick(int mx, int my) override;
	void Process(double ms) override;
protected:
	void DrawNumber(SDL_Rect location, char c);
	std::function<void(void)> onClick;
	SDL_Texture* texture=nullptr;
	std::string label{ "" };
};
#pragma once
#include "pch.h"
#include "SDL.h"


class ConsoleView {
private:
	std::list<std::string> data;
	SDL_Rect window;
	int maxLines = 10;
public:
	ConsoleView(int x, int y, int w, int h, int lines);
	void AddLine(std::string text);
	void Clear();
	void DrawNumber(SDL_Rect location, char c);
	void Draw();
};

#pragma once
#include "pch.h"

class Display
{
private:
	static Display* displayInstance;

	SDL_Window* window;
	SDL_Renderer* renderer;

	Display(int width, int height);
	~Display();

public:
	static int Width;
	static int Height;

	static void Create(int width, int height);

	static void Clear(Uint8 r, Uint8 g, Uint8 b);
	static void Present();
	
	static void DrawTexture(SDL_Texture* texture);
	static void DrawTexture(SDL_Texture* texture, const SDL_Rect* targetRect);
	static void DrawTexture(SDL_Texture* texture, const SDL_Rect* targetRect, const SDL_Rect* subTexture);

	static inline SDL_Window* GetWindow() { return displayInstance->window; }
	static inline SDL_Renderer* GetRenderer() { return displayInstance->renderer; }
};


class SDL_ClipRectSection {
	SDL_Rect oldRect;
public:
	SDL_ClipRectSection(int x, int y, int w, int h);
	~SDL_ClipRectSection(); 
};/*
Author:
Charles Wood
7-2-2020
*/

#pragma once
#include "pch.h"

class Font16 {
public:
	static void DrawText(const std::string &str, int x, int y);
	static int TextLength(const std::string &str, int at = INT32_MAX);

	/// <summary>
	/// Draws a 16x16 letter, but smashed width wise
	/// </summary>
	/// <param name="c"></param>
	/// <param name="x"></param>
	/// <param name="y"></param>
	/// <returns>Number of pixels wide the character was</returns>
	static int DrawLetter(char c, int x, int y);
};


#pragma once
#include "map.h"
#include "unit.h"
#include "viewport.h"
#include "pathfind.h"
#include "action.h"
#include "console.h"
#include "socketqueue.h"
#include "keymanager.h"
#include <functional>

class Game
{
public:
	static int mCellX, mCellY;
	static Game* gameInstance;

	static void Create();
	static void ProcessEvents();
	bool Process(double DeltaTime);
	void Draw(double deltaTime); 
	void StartUp(int x, int y);
	void NextPlayer();
	static inline bool IsRunning() { return gameInstance->running; }
	//To server
	void SendMessage(std::string st);


	void AddCallBack(std::function<void(std::string)> callBack);
	void RemoveCallBack();
	void SetRoomCode(const std::string& val);
public: //static
	void onSelectServerCallback(std::string url);
private:
	std::string roomCode = "";
	std::function<void(std::string)> callBacks;
	KeyboardManager keyMan;
	std::map<int, double> keys;  //numbers to wild for array....
	bool keyDown(int val);
	void HandleEvent(double ms);
	//This can only be used locally.
	static void addAction(Action* action, Action* ref = nullptr);
	SocketQueue *socketQueue=nullptr;

	bool running= false;
	//Camera Location
	double cx = 0;
	double cy = 0;

	Game();
	~Game();

	//Stuff we need for game
	Map* gameMap = nullptr;
	std::vector<GamePlayer> players;
	ViewPort viewPort;
	ConsoleView* console = nullptr;

	PathFinder* pathFinder = nullptr;

	int curPlayer = -1;
	int selUnit = -1;

	SDL_Point lastMouseCell{ -1,-1 };
	bool mouseDown = false;
	std::vector<Action*> actions;
	Uint64 now = 0;
	Uint64 last = 0;
	void handleMouse();
	void click();
	void selectUnit(int sp, int su);
	//Gets the character at cell x,y (not mouse location)
	bool getCharacterAt(int cx, int cy, int& sPlayer, int& sUnit);
	void keyPressed(int val);
	

	
};
#pragma once
#include "pch.h"
#include "unit.h"

class GamePlayer {
private:
	std::vector<Unit> units;
	//temp
	static constexpr int initUnits = 4;

public:
	GamePlayer();
	std::string GetJson();
	inline std::vector<Unit>& GetUnits()  { return units; }
	inline Unit& GetUnit(int idx) { return units[idx]; }
};
#pragma once
#include <iostream>

class Json {
public:
	static inline std::string Jsonify(std::string key, std::string value) {
		return " \"" + key + "\": \"" + value + "\"";
	}
	static inline std::string Jsonify(std::string key, int value) {
		return " \"" + key + "\": \"" + std::to_string(value) + "\"";
	}

};
#pragma once
#include "pch.h"



class KeyboardManager {
public:
    KeyboardManager();
    static KeyboardManager* KeyManager;
    void Process(double ms);
    void SetCallBack(std::function<void(const int)> a);
    static void AddKeyDown(int key, bool shift);
    void SetShift(bool state);
private:
    static std::list<int> keyQueue;

    bool shiftState { false };
    std::function<void(int)> callBack;
    
};
#pragma once
#include "pch.h"
#include "visualbase.h"

class Label : public VisBase {
public:
	Label(int x, int y, int w, int h);
	void SetText(std::string val);
	void SetTexture(SDL_Texture* tex);
	void SetOnClick(std::function<void(void)> func);
	void MouseIn() override;
	void MouseOut() override;
	void MouseDown(int mx, int my) override;
	void MouseUp() override;
	void Draw() override;
	void MouseClick(int mx, int my) override;
	void Process(double ms) override;
protected:
	std::function<void(void)> onClick;
	SDL_Texture* texture = nullptr;
	std::string label{ "" };
};

#pragma once

#include "maptile.h"

class Map {
public:
	friend class PathFind;
	static constexpr int Size = 128;  //Need a power of 2......
	static constexpr int TileSize = 64;
private:
	MapTile map[Size][Size];
public:
	Map();
	void Generate();
	int get(int x, int y);
	MapTile& Get(int x, int y);
	//Stuff to get/set later
	bool highlighted = false;
};
#pragma once
#include "pch.h"

enum class MapCellType {
	DEEP_SEA = 0,
	WATER,
	SHALLOW_WATER,
	MARSH,
	GRASS,
	STEPPE,
	HILL,
	ROCKY,
	SNOW,
	NONE,
	DESTROYED
};

//This is a location on the map, stored inside the map
class MapTile {
private:
	MapCellType type = MapCellType::NONE;
	int imgOffset = 0;
	friend class PathFind;
	int speed = 99;
	int getSpeed();
public:
	bool selected = false;
	MapTile();
	MapTile(int val);
	MapTile(MapCellType type);
	void Draw(SDL_Rect dest);
	inline int GetTestCellVal() { return (int)type; }
	inline int GetTestCellOfs() { return imgOffset; }
	inline int GetSpeed() { return speed; }

};
#pragma once
#include "pch.h"
#include "visualbase.h"

/// <summary>
/// Owner is responsible for *items
/// </summary>
class MouseManager {
public:
	MouseManager(std::vector<VisBase*>* items);
	void Process(int mx, int my, int mb);
	~MouseManager();
private:
	std::vector<VisBase*>* viewItems = nullptr;
	VisBase* lastHover = nullptr;
	VisBase* lastDown = nullptr;
	int mouseDown = 0;
};

#pragma once

#include "pch.h"
#include "maptile.h"
#include "map.h"
#include <vector>
#include "unit.h"



class PathFinder {
private:
    typedef std::tuple<int, int, int> xyRange;

    std::array<std::array<int, Map::Size>, Map::Size>* dRange = nullptr;
    std::vector<SDL_Point> path;
    
    void calcFlood(int x, int y, int maxSpeed);
    bool rangeOpen(int x, int y, int &speed);
    Map& map;
    xyRange pathGood(int x, int y);
public:
    PathFinder(Map& map);
    void DoUnitMaxDistanceTravel(const Unit& who, int val);
    void DoUnitMaxDistanceAttack(const Unit& who, int val, bool aerial);
    void ResetMap();

    

    //Current unit is selected, so this should be simple....
    std::vector<SDL_Point> GetPathTo(int x, int y);

    
    /// <summary>
    /// Returns the distance from calculated path.
    /// </summary>
    /// <param name="x"></param>
    /// <param name="y"></param>
    /// <returns>Returns the distance from calculated path.</returns>
    int GetRange(int x, int y);
    
    ~PathFinder();
};
#pragma once

#include <array>
#include <list>
#include <string>
#include <vector>
   
#include <iostream>
#include <sstream>
#include <fstream>

#include <functional>
#include <memory>
#include <map>

#include <SDL.h>
#pragma once



/// <summary>
/// Do not use new on this.  Just put it on the stack.  Loop through until paths are verified, then go out of scope.
/// </summary>
class PerlinMap {
private:
	int seed = 0;
	int width = 0;
	int height = 0;
	float* svalues = nullptr;
	float* evalues = nullptr;
	const int octaves = 6;
public:
	PerlinMap(int x, int y);
	~PerlinMap();
	/// <summary>
	/// Randomizes the source numbers, taking a new seed - if 
	/// </summary>
	void Randomize(int seed);
	void MakePerlin();
	void Normalize();
	//this will be enum soon
	int GetTerrain(int x, int y, int max);
	static void TestDraw();
};#pragma once
#include "pch.h"
#include "game.h"
#include <functional>


class MessageCallBack {
public:
	MessageCallBack(std::function<void(std::string)> iCallBack);
	~MessageCallBack();
private:
	std::function<void(std::string)> callBack;
};
#pragma once
#include "pch.h"
#include "threadqueue.h"
#include "../3rd/easywsclient.hpp"

class SocketQueue {
public:
	SocketQueue(std::string url );
	bool Send(std::string val);
	bool Avail();
	std::string Get();
	bool Start();
	void Process();
	void Stop();

private:
	std::unique_ptr<easywsclient::WebSocket> ws;
	std::string url;
	ThreadQueue<std::string> qOut;
	ThreadQueue<std::string> qIn;
//Stuff for thread access...
	static SocketQueue *instance;
};
#pragma once
#include "pch.h"
#include "visualbase.h"

class TextBox : public VisBase {
public:
	TextBox(int x, int y, int w, int h);
	void SetText(std::string val);
	std::string GetText();
	void SetTexture(SDL_Texture* tex);
	void SetOnClick(std::function<void(void)> func);
	void MouseIn() override;
	void MouseOut() override;
	void MouseDown(int mx, int my) override;
	void MouseUp() override;
	void Draw() override;
	void MouseClick(int mx, int my) override;
	void Process(double ms) override;
	void KeyIn(int key);
	inline void SetCaps(bool val) { allCaps = val; };
	inline void SetLetters(std::string val) { allowedChars = val; };
	inline void SetMaxLength(size_t val) { maxLen = val; };
protected:
	bool allCaps;
	std::string allowedChars{ "" };
	size_t maxLen = 256;
	double curTime = 0;
	bool showCursor{ false };
	int curX = 0;
	std::function<void(void)> onClick;
	SDL_Texture* texture = nullptr;
	std::string label{ "" };
};

#pragma once
#include <queue>
#include <mutex>
#include <condition_variable>

// A threadsafe-queue.
template <class T>
class ThreadQueue
{
public:
    ThreadQueue(void)
        : q()
        , m()
        , c()
    {}

    ~ThreadQueue(void)
    {}

    // Add an element to the queue.
    void Enqueue(T t)
    {
        std::lock_guard<std::mutex> lock(m);
        q.push(t);
        c.notify_one();
    }

    //Return the size, avoids stalls on dequeue
    size_t Size() {
        std::unique_lock<std::mutex> lock(m);
        return q.size();
    }

    // Get the "front"-element.
    // If the queue is empty, wait till a element is avaiable.
    T Dequeue(void)
    {
        std::unique_lock<std::mutex> lock(m);
        while (q.empty())
        {
            // release lock as long as the wait and reaquire it afterwards.
            c.wait(lock);
        }
        T val = q.front();
        q.pop();
        return val;
    }
private:
    std::queue<T> q;
    mutable std::mutex m;
    std::condition_variable c;
};
#pragma once
#include "pch.h"
#include <string>

enum class UnitType {
	Warrior = 0,
	Spear,
	Archer,
	Wizard,
};

enum class WeaponType
{
	None = 0,
	Melee,
	Ranged,
	Magic
};

class Unit {
private:
	UnitType type;
	WeaponType weapon;
	SDL_Rect rect;
	SDL_Texture* texture;

	int hp = 50;
	//Speed is how many regular tiles it can travel per round/Tile slowness.
	int speed = 20;

	int constitution = 50;
	int range;
	float damage;

	float x=1;
	float y=2;

public:
	static constexpr int ConstMax = 50;
	Unit(UnitType type, int x, int y);
	std::string GetJson();
	void Draw(SDL_Rect dest);

	inline int GetX() const { return (int) (x+.5f); }
	inline int GetY() const { return (int) (y+.5f); }
	//These return the float positions.
	inline float GetXF() const { return x; }
	inline float GetYF() const { return y; }

	inline int GetSpeed() const { return speed; }
	inline void Move(int dx, int dy) {
		x = (float) dx; y = (float) dy;
	}
	//This is for animations, to partial move the character.
	inline void MoveF(float dx, float dy) {
		x = dx; y = dy;
	}

};#pragma once
#include "pch.h"
#include "map.h"
#include "unit.h"
#include "gameplayer.h"
#include "pathfind.h"

class ViewPort {
private:
	int topX=0, topY=0;
	int width=0, height=0;
	float zoom = 1.0f;
	//Camera Location
	double camX=0.0, camY=0.0;  
	double camTX=0.0, camTY=0.0;
public:
	ViewPort(int x, int y, int w, int h, float zoom);
	ViewPort() = default;
	
	void SetCamera(double& x, double& y);
	void Update(int ms);
	void Draw(Map& map, std::vector<GamePlayer> players, PathFinder *pathFinder);
	void DoSomething();
	bool GetCellAtMouseXY(int mx, int my, int& x, int& y);
	void RenderTextureAt(int cx, int cy, int ocx, int ocy, SDL_Texture* tex, SDL_Rect* sourceRect);
	bool MouseInViewPort(int x, int y);
	void DrawNumber(SDL_Rect location, int value);





};
#pragma once
#include "pch.h"
#include <functional>

class VisBase {
public:
	virtual void MouseIn() = 0;
	virtual void MouseOut() = 0;
	virtual void MouseDown(int mx, int my) = 0;
	virtual void MouseUp() = 0;
	virtual void MouseClick(int mx, int my) = 0;
	virtual void Draw() = 0;
	virtual void Process(double ms) = 0;
protected:
	friend class MouseManager;
	SDL_Rect location{ 0 };
	bool hover = false;
	bool down = false;
};
