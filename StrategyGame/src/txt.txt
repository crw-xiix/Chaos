#include "pch.h"
#include "action.h"


bool ActionPlayLocal::Process(double time)
{
    return false;
}

void ActionPlayLocal::Click()
{
}

ActionMovePlayer::ActionMovePlayer(Unit& who, int x, int y): actor(who)
{
    tx = x;
    ty = y;
}

bool ActionMovePlayer::Process(double time)
{
    float dx = tx - actor.GetXF();
    float dy = ty - actor.GetYF();
    double l = sqrt(dx * dx + dy * dy);
    dx /= l; 
    dy /= l;
    actor.MoveF(actor.GetXF() + dx*time*4, actor.GetYF() + dy*time*4);
    if (l < 0.05) {
        actor.Move(tx, ty);
        return true;
    }
    return false;
}

void ActionMovePlayer::Click()
{
}

Action::Action()
{
}
#include "pch.h"
#include "unit.h"


class Action {
public:
	//Returns true if Process is complete.
	virtual bool Process(double time) = 0;
	virtual void Click() = 0;
	Action();
	
};

class ActionPlayLocal : public Action {
	bool Process(double time);
	void Click();
};



class ActionMovePlayer : public Action {
	int tx, ty;
	Unit& actor;
public:
	ActionMovePlayer(Unit& who, int x, int y);
	bool Process(double time);
	void Click();
};


//XXXC CRW  Need action request, action join, action waiting, action playing and action 
//game over.  Also have to do point inserts on action lists.
#include "pch.h"
#include "animation.h"
#pragma once

class Animation
{
private:

public:
	virtual ~Animation() = default;

	virtual void Start() = 0;
};

class AnimationArrow : public Animation
{
private:
public:
};#pragma once
#include "pch.h"
#include "assetmgr.h"


void AssetMgr::Destroy()
{
	for (auto i : AssetMgr::Images) SDL_DestroyTexture(i.second);
}

bool AssetMgr::Load(std::string filename, std::string nick)
{
	SDL_Texture* texture = IMG_LoadTexture(Display::GetRenderer(), filename.c_str());
	Images[nick] = texture;
	return false;
}

SDL_Texture* AssetMgr::Get(std::string nick, int gridSize, int x, int y, SDL_Rect& dest) {
	SDL_Texture* tex = Images[nick];
	if (tex == nullptr) return tex;
	dest.x = gridSize * x;
	dest.y = gridSize * y;
	dest.w = gridSize;
	dest.h = gridSize;
	return tex;
}

SDL_Texture* AssetMgr::GetAll(std::string nick, SDL_Rect& dest)
{
	SDL_Texture* tex = Images[nick];
	Uint32 fmt;
	int acs;
	dest.x = 0;
	dest.y = 0;
	SDL_QueryTexture(tex, &fmt, &acs, &dest.w, &dest.h);
		
	return tex;
}


//Statics
std::map<std::string, SDL_Texture*> AssetMgr::Images;
#pragma once
#include "pch.h"
#include "display.h"
#include "SDL_image.h"

class AssetMgr {
private:
	
	
	
public:
	static void Destroy();
	static std::map<std::string, SDL_Texture*> Images;
	static bool Load(std::string filename, std::string nick);
	static SDL_Texture* Get(std::string nick, int gridSize, int x, int y, SDL_Rect& dest);
	static SDL_Texture* GetAll(std::string nick, SDL_Rect& dest);
};

clear
g++ -I/usr/include/SDL2 -I. game.cpp assetmgr.cpp pathfind.cpp map.cpp unit.cpp gameplayer.cpp viewport.cpp perlinmap.cpp display.cpp maptile.cpp main.cpp -o main `sdl2-config --cflags --libs` -lSDL2 -lSDL2_image
./main

#include "pch.h"
#include "display.h"

Display::Display(int width, int height)
	: window(nullptr), renderer(nullptr), width(width), height(height)
{
	if (SDL_CreateWindowAndRenderer(width, height, 0, &window, &renderer) < 0)
	{
		std::cout << "Failed to create display: " << SDL_GetError() << "\n";
	}
}

Display::~Display()
{
	SDL_DestroyRenderer(renderer);
	SDL_DestroyWindow(window);

	delete displayInstance;
}

void Display::Create(int width, int height)
{
	displayInstance = new Display(width, height);
}

void Display::Clear(Uint8 r, Uint8 g, Uint8 b)
{
	SDL_SetRenderDrawColor(GetRenderer(), r, g, b, 255);
	SDL_RenderClear(GetRenderer());
}

void Display::Present()
{
	SDL_RenderPresent(GetRenderer());
}

void Display::DrawTexture(SDL_Texture* texture)
{
	SDL_RenderCopy(GetRenderer(), texture, nullptr, nullptr);
}

void Display::DrawTexture(SDL_Texture* texture, const SDL_Rect* targetRect)
{
	SDL_RenderCopy(GetRenderer(), texture, nullptr, targetRect);
}

void Display::DrawTexture(SDL_Texture* texture, const SDL_Rect* targetRect, const SDL_Rect* subTexture)
{
	SDL_RenderCopy(GetRenderer(), texture, targetRect, subTexture);
}

/*Static members*/
Display* Display::displayInstance;

SDL_ClipRectSection::SDL_ClipRectSection(int x, int y, int w, int h)
{
	SDL_RenderGetClipRect(Display::GetRenderer(), &oldRect);
	SDL_Rect clip= { x,y,w,h };
	SDL_RenderSetClipRect(Display::GetRenderer(), &clip);
}

SDL_ClipRectSection::~SDL_ClipRectSection()
{
	SDL_RenderSetClipRect(Display::GetRenderer(), &oldRect);
}
#pragma once
#include "pch.h"

class Display
{
private:
	static Display* displayInstance;

	SDL_Window* window;
	SDL_Renderer* renderer;

	int width;
	int height;

	Display(int width, int height);
	~Display();

public:

	static void Create(int width, int height);

	static void Clear(Uint8 r, Uint8 g, Uint8 b);
	static void Present();
	
	static void DrawTexture(SDL_Texture* texture);
	static void DrawTexture(SDL_Texture* texture, const SDL_Rect* targetRect);
	static void DrawTexture(SDL_Texture* texture, const SDL_Rect* targetRect, const SDL_Rect* subTexture);

	static inline SDL_Window* GetWindow() { return displayInstance->window; }
	static inline SDL_Renderer* GetRenderer() { return displayInstance->renderer; }
};


class SDL_ClipRectSection {
	SDL_Rect oldRect;
public:
	SDL_ClipRectSection(int x, int y, int w, int h);
	~SDL_ClipRectSection(); 
};#include "pch.h"
#ifdef _WIN32
    #if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)
        #define _CRT_SECURE_NO_WARNINGS // _CRT_SECURE_NO_WARNINGS for sscanf errors in MSVC2013 Express
    #endif
    #ifndef WIN32_LEAN_AND_MEAN
        #define WIN32_LEAN_AND_MEAN
    #endif
    #include <fcntl.h>
    #include <WinSock2.h>
    #include <WS2tcpip.h>
    #pragma comment( lib, "ws2_32" )
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>
    #include <sys/types.h>
    #include <io.h>
    #ifndef _SSIZE_T_DEFINED
        typedef int ssize_t;
        #define _SSIZE_T_DEFINED
    #endif
    #ifndef _SOCKET_T_DEFINED
        typedef SOCKET socket_t;
        #define _SOCKET_T_DEFINED
    #endif
    #ifndef snprintf
        #define snprintf _snprintf_s
    #endif
    #if _MSC_VER >=1600
        // vs2010 or later
        #include <stdint.h>
    #else
        typedef __int8 int8_t;
        typedef unsigned __int8 uint8_t;
        typedef __int32 int32_t;
        typedef unsigned __int32 uint32_t;
        typedef __int64 int64_t;
        typedef unsigned __int64 uint64_t;
    #endif
    #define socketerrno WSAGetLastError()
    #define SOCKET_EAGAIN_EINPROGRESS WSAEINPROGRESS
    #define SOCKET_EWOULDBLOCK WSAEWOULDBLOCK
#else
    #include <fcntl.h>
    #include <netdb.h>
    #include <netinet/tcp.h>
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>
    #include <sys/socket.h>
    #include <sys/time.h>
    #include <sys/types.h>
    #include <unistd.h>
    #include <stdint.h>
    #ifndef _SOCKET_T_DEFINED
        typedef int socket_t;
        #define _SOCKET_T_DEFINED
    #endif
    #ifndef INVALID_SOCKET
        #define INVALID_SOCKET (-1)
    #endif
    #ifndef SOCKET_ERROR
        #define SOCKET_ERROR   (-1)
    #endif
    #define closesocket(s) ::close(s)
    #include <errno.h>
    #define socketerrno errno
    #define SOCKET_EAGAIN_EINPROGRESS EAGAIN
    #define SOCKET_EWOULDBLOCK EWOULDBLOCK
#endif

#include <vector>
#include <string>

#include "easywsclient.hpp"

using easywsclient::Callback_Imp;
using easywsclient::BytesCallback_Imp;

namespace { // private module-only namespace

socket_t hostname_connect(const std::string& hostname, int port) {
    struct addrinfo hints;
    struct addrinfo *result;
    struct addrinfo *p;
    int ret;
    socket_t sockfd = INVALID_SOCKET;
    char sport[16];
    memset(&hints, 0, sizeof(hints));
    hints.ai_family = AF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;
    snprintf(sport, 16, "%d", port);
    if ((ret = getaddrinfo(hostname.c_str(), sport, &hints, &result)) != 0)
    {
      fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(ret));
      return 1;
    }
    for(p = result; p != NULL; p = p->ai_next)
    {
        sockfd = socket(p->ai_family, p->ai_socktype, p->ai_protocol);
        if (sockfd == INVALID_SOCKET) { continue; }
        if (connect(sockfd, p->ai_addr, p->ai_addrlen) != SOCKET_ERROR) {
            break;
        }
        closesocket(sockfd);
        sockfd = INVALID_SOCKET;
    }
    freeaddrinfo(result);
    return sockfd;
}


class _DummyWebSocket : public easywsclient::WebSocket
{
  public:
    void poll(int timeout) { }
    void send(const std::string& message) { }
    void sendBinary(const std::string& message) { }
    void sendBinary(const std::vector<uint8_t>& message) { }
    void sendPing() { }
    void close() { } 
    readyStateValues getReadyState() const { return CLOSED; }
    void _dispatch(Callback_Imp & callable) { }
    void _dispatchBinary(BytesCallback_Imp& callable) { }
};


class _RealWebSocket : public easywsclient::WebSocket
{
  public:
    // http://tools.ietf.org/html/rfc6455#section-5.2  Base Framing Protocol
    //
    //  0                   1                   2                   3
    //  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    // +-+-+-+-+-------+-+-------------+-------------------------------+
    // |F|R|R|R| opcode|M| Payload len |    Extended payload length    |
    // |I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |
    // |N|V|V|V|       |S|             |   (if payload len==126/127)   |
    // | |1|2|3|       |K|             |                               |
    // +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +
    // |     Extended payload length continued, if payload len == 127  |
    // + - - - - - - - - - - - - - - - +-------------------------------+
    // |                               |Masking-key, if MASK set to 1  |
    // +-------------------------------+-------------------------------+
    // | Masking-key (continued)       |          Payload Data         |
    // +-------------------------------- - - - - - - - - - - - - - - - +
    // :                     Payload Data continued ...                :
    // + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
    // |                     Payload Data continued ...                |
    // +---------------------------------------------------------------+
    struct wsheader_type {
        unsigned header_size;
        bool fin;
        bool mask;
        enum opcode_type {
            CONTINUATION = 0x0,
            TEXT_FRAME = 0x1,
            BINARY_FRAME = 0x2,
            CLOSE = 8,
            PING = 9,
            PONG = 0xa,
        } opcode;
        int N0;
        uint64_t N;
        uint8_t masking_key[4];
    };

    std::vector<uint8_t> rxbuf;
    std::vector<uint8_t> txbuf;
    std::vector<uint8_t> receivedData;

    socket_t sockfd;
    readyStateValues readyState;
    bool useMask;
    bool isRxBad;

    _RealWebSocket(socket_t sockfd, bool useMask)
            : sockfd(sockfd)
            , readyState(OPEN)
            , useMask(useMask)
            , isRxBad(false) {
    }

    readyStateValues getReadyState() const {
      return readyState;
    }

    void poll(int timeout) { // timeout in milliseconds
        if (readyState == CLOSED) {
            if (timeout > 0) {
                timeval tv = { timeout/1000, (timeout%1000) * 1000 };
                select(0, NULL, NULL, NULL, &tv);
            }
            return;
        }
        if (timeout != 0) {
            fd_set rfds;
            fd_set wfds;
            timeval tv = { timeout/1000, (timeout%1000) * 1000 };
            FD_ZERO(&rfds);
            FD_ZERO(&wfds);
            FD_SET(sockfd, &rfds);
            if (txbuf.size()) { FD_SET(sockfd, &wfds); }
            select(sockfd + 1, &rfds, &wfds, 0, timeout > 0 ? &tv : 0);
        }
        while (true) {
            // FD_ISSET(0, &rfds) will be true
            int N = rxbuf.size();
            ssize_t ret;
            rxbuf.resize(N + 1500);
            ret = recv(sockfd, (char*)&rxbuf[0] + N, 1500, 0);
            if (false) { }
            else if (ret < 0 && (socketerrno == SOCKET_EWOULDBLOCK || socketerrno == SOCKET_EAGAIN_EINPROGRESS)) {
                rxbuf.resize(N);
                break;
            }
            else if (ret <= 0) {
                rxbuf.resize(N);
                closesocket(sockfd);
                readyState = CLOSED;
                fputs(ret < 0 ? "Connection error!\n" : "Connection closed!\n", stderr);
                break;
            }
            else {
                rxbuf.resize(N + ret);
            }
        }
        while (txbuf.size()) {
            int ret = ::send(sockfd, (char*)&txbuf[0], txbuf.size(), 0);
            if (false) { } // ??
            else if (ret < 0 && (socketerrno == SOCKET_EWOULDBLOCK || socketerrno == SOCKET_EAGAIN_EINPROGRESS)) {
                break;
            }
            else if (ret <= 0) {
                closesocket(sockfd);
                readyState = CLOSED;
                fputs(ret < 0 ? "Connection error!\n" : "Connection closed!\n", stderr);
                break;
            }
            else {
                txbuf.erase(txbuf.begin(), txbuf.begin() + ret);
            }
        }
        if (!txbuf.size() && readyState == CLOSING) {
            closesocket(sockfd);
            readyState = CLOSED;
        }
    }

    // Callable must have signature: void(const std::string & message).
    // Should work with C functions, C++ functors, and C++11 std::function and
    // lambda:
    //template<class Callable>
    //void dispatch(Callable callable)
    virtual void _dispatch(Callback_Imp & callable) {
        struct CallbackAdapter : public BytesCallback_Imp
            // Adapt void(const std::string<uint8_t>&) to void(const std::string&)
        {
            Callback_Imp& callable;
            CallbackAdapter(Callback_Imp& callable) : callable(callable) { }
            void operator()(const std::vector<uint8_t>& message) {
                std::string stringMessage(message.begin(), message.end());
                callable(stringMessage);
            }
        };
        CallbackAdapter bytesCallback(callable);
        _dispatchBinary(bytesCallback);
    }

    virtual void _dispatchBinary(BytesCallback_Imp & callable) {
        // TODO: consider acquiring a lock on rxbuf...
        if (isRxBad) {
            return;
        }
        while (true) {
            wsheader_type ws;
            if (rxbuf.size() < 2) { return; /* Need at least 2 */ }
            const uint8_t * data = (uint8_t *) &rxbuf[0]; // peek, but don't consume
            ws.fin = (data[0] & 0x80) == 0x80;
            ws.opcode = (wsheader_type::opcode_type) (data[0] & 0x0f);
            ws.mask = (data[1] & 0x80) == 0x80;
            ws.N0 = (data[1] & 0x7f);
            ws.header_size = 2 + (ws.N0 == 126? 2 : 0) + (ws.N0 == 127? 8 : 0) + (ws.mask? 4 : 0);
            if (rxbuf.size() < ws.header_size) { return; /* Need: ws.header_size - rxbuf.size() */ }
            int i = 0;
            if (ws.N0 < 126) {
                ws.N = ws.N0;
                i = 2;
            }
            else if (ws.N0 == 126) {
                ws.N = 0;
                ws.N |= ((uint64_t) data[2]) << 8;
                ws.N |= ((uint64_t) data[3]) << 0;
                i = 4;
            }
            else if (ws.N0 == 127) {
                ws.N = 0;
                ws.N |= ((uint64_t) data[2]) << 56;
                ws.N |= ((uint64_t) data[3]) << 48;
                ws.N |= ((uint64_t) data[4]) << 40;
                ws.N |= ((uint64_t) data[5]) << 32;
                ws.N |= ((uint64_t) data[6]) << 24;
                ws.N |= ((uint64_t) data[7]) << 16;
                ws.N |= ((uint64_t) data[8]) << 8;
                ws.N |= ((uint64_t) data[9]) << 0;
                i = 10;
                if (ws.N & 0x8000000000000000ull) {
                    // https://tools.ietf.org/html/rfc6455 writes the "the most
                    // significant bit MUST be 0."
                    //
                    // We can't drop the frame, because (1) we don't we don't
                    // know how much data to skip over to find the next header,
                    // and (2) this would be an impractically long length, even
                    // if it were valid. So just close() and return immediately
                    // for now.
                    isRxBad = true;
                    fprintf(stderr, "ERROR: Frame has invalid frame length. Closing.\n");
                    close();
                    return;
                }
            }
            if (ws.mask) {
                ws.masking_key[0] = ((uint8_t) data[i+0]) << 0;
                ws.masking_key[1] = ((uint8_t) data[i+1]) << 0;
                ws.masking_key[2] = ((uint8_t) data[i+2]) << 0;
                ws.masking_key[3] = ((uint8_t) data[i+3]) << 0;
            }
            else {
                ws.masking_key[0] = 0;
                ws.masking_key[1] = 0;
                ws.masking_key[2] = 0;
                ws.masking_key[3] = 0;
            }

            // Note: The checks above should hopefully ensure this addition
            //       cannot overflow:
            if (rxbuf.size() < ws.header_size+ws.N) { return; /* Need: ws.header_size+ws.N - rxbuf.size() */ }

            // We got a whole message, now do something with it:
            if (false) { }
            else if (
                   ws.opcode == wsheader_type::TEXT_FRAME 
                || ws.opcode == wsheader_type::BINARY_FRAME
                || ws.opcode == wsheader_type::CONTINUATION
            ) {
                if (ws.mask) { for (size_t i = 0; i != ws.N; ++i) { rxbuf[i+ws.header_size] ^= ws.masking_key[i&0x3]; } }
                receivedData.insert(receivedData.end(), rxbuf.begin()+ws.header_size, rxbuf.begin()+ws.header_size+(size_t)ws.N);// just feed
                if (ws.fin) {
                    callable((const std::vector<uint8_t>) receivedData);
                    receivedData.erase(receivedData.begin(), receivedData.end());
                    std::vector<uint8_t> ().swap(receivedData);// free memory
                }
            }
            else if (ws.opcode == wsheader_type::PING) {
                if (ws.mask) { for (size_t i = 0; i != ws.N; ++i) { rxbuf[i+ws.header_size] ^= ws.masking_key[i&0x3]; } }
                std::string data(rxbuf.begin()+ws.header_size, rxbuf.begin()+ws.header_size+(size_t)ws.N);
                sendData(wsheader_type::PONG, data.size(), data.begin(), data.end());
            }
            else if (ws.opcode == wsheader_type::PONG) { }
            else if (ws.opcode == wsheader_type::CLOSE) { close(); }
            else { fprintf(stderr, "ERROR: Got unexpected WebSocket message.\n"); close(); }

            rxbuf.erase(rxbuf.begin(), rxbuf.begin() + ws.header_size+(size_t)ws.N);
        }
    }

    void sendPing() {
        std::string empty;
        sendData(wsheader_type::PING, empty.size(), empty.begin(), empty.end());
    }

    void send(const std::string& message) {
        sendData(wsheader_type::TEXT_FRAME, message.size(), message.begin(), message.end());
    }

    void sendBinary(const std::string& message) {
        sendData(wsheader_type::BINARY_FRAME, message.size(), message.begin(), message.end());
    }

    void sendBinary(const std::vector<uint8_t>& message) {
        sendData(wsheader_type::BINARY_FRAME, message.size(), message.begin(), message.end());
    }

    template<class Iterator>
    void sendData(wsheader_type::opcode_type type, uint64_t message_size, Iterator message_begin, Iterator message_end) {
        // TODO:
        // Masking key should (must) be derived from a high quality random
        // number generator, to mitigate attacks on non-WebSocket friendly
        // middleware:
        const uint8_t masking_key[4] = { 0x12, 0x34, 0x56, 0x78 };
        // TODO: consider acquiring a lock on txbuf...
        if (readyState == CLOSING || readyState == CLOSED) { return; }
        std::vector<uint8_t> header;
        header.assign(2 + (message_size >= 126 ? 2 : 0) + (message_size >= 65536 ? 6 : 0) + (useMask ? 4 : 0), 0);
        header[0] = 0x80 | type;
        if (false) { }
        else if (message_size < 126) {
            header[1] = (message_size & 0xff) | (useMask ? 0x80 : 0);
            if (useMask) {
                header[2] = masking_key[0];
                header[3] = masking_key[1];
                header[4] = masking_key[2];
                header[5] = masking_key[3];
            }
        }
        else if (message_size < 65536) {
            header[1] = 126 | (useMask ? 0x80 : 0);
            header[2] = (message_size >> 8) & 0xff;
            header[3] = (message_size >> 0) & 0xff;
            if (useMask) {
                header[4] = masking_key[0];
                header[5] = masking_key[1];
                header[6] = masking_key[2];
                header[7] = masking_key[3];
            }
        }
        else { // TODO: run coverage testing here
            header[1] = 127 | (useMask ? 0x80 : 0);
            header[2] = (message_size >> 56) & 0xff;
            header[3] = (message_size >> 48) & 0xff;
            header[4] = (message_size >> 40) & 0xff;
            header[5] = (message_size >> 32) & 0xff;
            header[6] = (message_size >> 24) & 0xff;
            header[7] = (message_size >> 16) & 0xff;
            header[8] = (message_size >>  8) & 0xff;
            header[9] = (message_size >>  0) & 0xff;
            if (useMask) {
                header[10] = masking_key[0];
                header[11] = masking_key[1];
                header[12] = masking_key[2];
                header[13] = masking_key[3];
            }
        }
        // N.B. - txbuf will keep growing until it can be transmitted over the socket:
        txbuf.insert(txbuf.end(), header.begin(), header.end());
        txbuf.insert(txbuf.end(), message_begin, message_end);
        if (useMask) {
            size_t message_offset = txbuf.size() - message_size;
            for (size_t i = 0; i != message_size; ++i) {
                txbuf[message_offset + i] ^= masking_key[i&0x3];
            }
        }
    }

    void close() {
        if(readyState == CLOSING || readyState == CLOSED) { return; }
        readyState = CLOSING;
        uint8_t closeFrame[6] = {0x88, 0x80, 0x00, 0x00, 0x00, 0x00}; // last 4 bytes are a masking key
        std::vector<uint8_t> header(closeFrame, closeFrame+6);
        txbuf.insert(txbuf.end(), header.begin(), header.end());
    }

};


easywsclient::WebSocket::pointer from_url(const std::string& url, bool useMask, const std::string& origin) {
    char host[512];
    int port;
    char path[512];
    if (url.size() >= 512) {
      fprintf(stderr, "ERROR: url size limit exceeded: %s\n", url.c_str());
      return NULL;
    }
    if (origin.size() >= 200) {
      fprintf(stderr, "ERROR: origin size limit exceeded: %s\n", origin.c_str());
      return NULL;
    }
    if (false) { }
    else if (sscanf_s(url.c_str(), "ws://%[^:/]:%d/%s", host,512, &port, path,512) == 3) {
    }
    else if (sscanf_s(url.c_str(), "ws://%[^:/]/%s", host,512, path, 512) == 2) {
        port = 80;
    }
    else if (sscanf_s(url.c_str(), "ws://%[^:/]:%d", host,512, &port) == 2) {
        path[0] = '\0';
    }
    else if (sscanf_s(url.c_str(), "ws://%[^:/]", host, 512) == 1) {
        port = 80;
        path[0] = '\0';
    }
    else {
        fprintf(stderr, "ERROR: Could not parse WebSocket url: %s\n", url.c_str());
        return NULL;
    }
    //fprintf(stderr, "easywsclient: connecting: host=%s port=%d path=/%s\n", host, port, path);
    socket_t sockfd = hostname_connect(host, port);
    if (sockfd == INVALID_SOCKET) {
        fprintf(stderr, "Unable to connect to %s:%d\n", host, port);
        return NULL;
    }
    {
        // XXX: this should be done non-blocking,
        char line[1024];
        int status;
        int i;
        snprintf(line, 1024, "GET /%s HTTP/1.1\r\n", path); ::send(sockfd, line, strlen(line), 0);
        if (port == 80) {
            snprintf(line, 1024, "Host: %s\r\n", host); ::send(sockfd, line, strlen(line), 0);
        }
        else {
            snprintf(line, 1024, "Host: %s:%d\r\n", host, port); ::send(sockfd, line, strlen(line), 0);
        }
        snprintf(line, 1024, "Upgrade: websocket\r\n"); ::send(sockfd, line, strlen(line), 0);
        snprintf(line, 1024, "Connection: Upgrade\r\n"); ::send(sockfd, line, strlen(line), 0);
        if (!origin.empty()) {
            snprintf(line, 1024, "Origin: %s\r\n", origin.c_str()); ::send(sockfd, line, strlen(line), 0);
        }
        snprintf(line, 1024, "Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==\r\n"); ::send(sockfd, line, strlen(line), 0);
        snprintf(line, 1024, "Sec-WebSocket-Version: 13\r\n"); ::send(sockfd, line, strlen(line), 0);
        snprintf(line, 1024, "\r\n"); ::send(sockfd, line, strlen(line), 0);
        for (i = 0; i < 2 || (i < 1023 && line[i-2] != '\r' && line[i-1] != '\n'); ++i) { if (recv(sockfd, line+i, 1, 0) == 0) { return NULL; } }
        line[i] = 0;
        if (i == 1023) { fprintf(stderr, "ERROR: Got invalid status line connecting to: %s\n", url.c_str()); return NULL; }
        if (sscanf_s(line, "HTTP/1.1 %d", &status) != 1 || status != 101) { fprintf(stderr, "ERROR: Got bad status connecting to %s: %s", url.c_str(), line); return NULL; }
        // TODO: verify response headers,
        while (true) {
            for (i = 0; i < 2 || (i < 1023 && line[i-2] != '\r' && line[i-1] != '\n'); ++i) { if (recv(sockfd, line+i, 1, 0) == 0) { return NULL; } }
            if (line[0] == '\r' && line[1] == '\n') { break; }
        }
    }
    int flag = 1;
    setsockopt(sockfd, IPPROTO_TCP, TCP_NODELAY, (char*) &flag, sizeof(flag)); // Disable Nagle's algorithm
#ifdef _WIN32
    u_long on = 1;
    ioctlsocket(sockfd, FIONBIO, &on);
#else
    fcntl(sockfd, F_SETFL, O_NONBLOCK);
#endif
    //fprintf(stderr, "Connected to: %s\n", url.c_str());
    return easywsclient::WebSocket::pointer(new _RealWebSocket(sockfd, useMask));
}

} // end of module-only namespace



namespace easywsclient {

WebSocket::pointer WebSocket::create_dummy() {
    static pointer dummy = pointer(new _DummyWebSocket);
    return dummy;
}


WebSocket::pointer WebSocket::from_url(const std::string& url, const std::string& origin) {
    return ::from_url(url, true, origin);
}

WebSocket::pointer WebSocket::from_url_no_mask(const std::string& url, const std::string& origin) {
    return ::from_url(url, false, origin);
}


} // namespace easywsclient
#ifndef EASYWSCLIENT_HPP_20120819_MIOFVASDTNUASZDQPLFD
#define EASYWSCLIENT_HPP_20120819_MIOFVASDTNUASZDQPLFD

// This code comes from:
// https://github.com/dhbaird/easywsclient
//
// To get the latest version:
// wget https://raw.github.com/dhbaird/easywsclient/master/easywsclient.hpp
// wget https://raw.github.com/dhbaird/easywsclient/master/easywsclient.cpp

#include <string>
#include <vector>

namespace easywsclient {

struct Callback_Imp { virtual void operator()(const std::string& message) = 0; };
struct BytesCallback_Imp { virtual void operator()(const std::vector<uint8_t>& message) = 0; };

class WebSocket {
  public:
    typedef WebSocket * pointer;
    typedef enum readyStateValues { CLOSING, CLOSED, CONNECTING, OPEN } readyStateValues;

    // Factories:
    static pointer create_dummy();
    static pointer from_url(const std::string& url, const std::string& origin = std::string());
    static pointer from_url_no_mask(const std::string& url, const std::string& origin = std::string());

    // Interfaces:
    virtual ~WebSocket() { }
    virtual void poll(int timeout = 0) = 0; // timeout in milliseconds
    virtual void send(const std::string& message) = 0;
    virtual void sendBinary(const std::string& message) = 0;
    virtual void sendBinary(const std::vector<uint8_t>& message) = 0;
    virtual void sendPing() = 0;
    virtual void close() = 0;
    virtual readyStateValues getReadyState() const = 0;

    template<class Callable>
    void dispatch(Callable callable)
        // For callbacks that accept a string argument.
    { // N.B. this is compatible with both C++11 lambdas, functors and C function pointers
        struct _Callback : public Callback_Imp {
            Callable& callable;
            _Callback(Callable& callable) : callable(callable) { }
            void operator()(const std::string& message) { callable(message); }
        };
        _Callback callback(callable);
        _dispatch(callback);
    }

    template<class Callable>
    void dispatchBinary(Callable callable)
        // For callbacks that accept a std::vector<uint8_t> argument.
    { // N.B. this is compatible with both C++11 lambdas, functors and C function pointers
        struct _Callback : public BytesCallback_Imp {
            Callable& callable;
            _Callback(Callable& callable) : callable(callable) { }
            void operator()(const std::vector<uint8_t>& message) { callable(message); }
        };
        _Callback callback(callable);
        _dispatchBinary(callback);
    }

  protected:
    virtual void _dispatch(Callback_Imp& callable) = 0;
    virtual void _dispatchBinary(BytesCallback_Imp& callable) = 0;
};

} // namespace easywsclient

#endif /* EASYWSCLIENT_HPP_20120819_MIOFVASDTNUASZDQPLFD */
#include "pch.h"
#include "pch.h"
#include "game.h"
#include "assetmgr.h"
#include "viewport.h"
#include "easywsclient.hpp"

/*
#include "websocketpp/config/asio_no_tls_client.hpp"
#include "websocketpp/client.hpp"
*/


//XXXC CRW Need an action for requestion new room, joining room, etc.

Game::Game()
	: running(true)
{

}

Game::~Game()
{
	delete gameInstance;
}

void Game::handleMouse()
{

	int mx, my;
	uint32_t mouseState = SDL_GetMouseState(&mx, &my);
	//Update the hover locations
	viewPort.GetCellAtMouseXY(mx, my, mCellX, mCellY);

	bool tMouseDown = mouseState & SDL_BUTTON_LEFT;
	if (tMouseDown != mouseDown) {   //State changed.
		if (tMouseDown) {
			viewPort.GetCellAtMouseXY(mx, my, lastMouseCell.x, lastMouseCell.y);
		}
		else { //Upclick
			int imx, imy;
			viewPort.GetCellAtMouseXY(mx, my, imx, imy);
			if ((imx == lastMouseCell.x) && (imy = lastMouseCell.y)) {
				click();
				lastMouseCell.x = -1;
				lastMouseCell.y = -1;
			}
		}
		mouseDown = tMouseDown;
	}
}

void Game::click()
{
	int sp, su;
	if (getCharacterAt(lastMouseCell.x, lastMouseCell.y, sp, su)) {
		//We have a character......
		int bp = 0;
		if (sp == curPlayer) {
			if (su != selUnit) {
				selectUnit(sp, su);
			};
		}
	}
	else {
		if (pathFinder->GetRange(lastMouseCell.x, lastMouseCell.y) > -1) {
			//This should be a valid move.
			auto& thisUnit = players[curPlayer].GetUnit(selUnit);
			auto fuckme = pathFinder->GetPathTo(lastMouseCell.x, lastMouseCell.y);
			for (auto me : fuckme) {
				addAction(new ActionMovePlayer(thisUnit, me.x, me.y));
				/*actions.insert(actions.begin(), ActionMovePlayer(thisUnit, me.x, me.y));
				actions.insert()*/
				}
			//thisUnit.Move(lastMouseCell.x, lastMouseCell.y);
			int bp = 0;
		}
		selUnit = -1;
		pathFinder->ResetMap();
	}
}

void Game::selectUnit(int sp, int su)
{
	int bp = 0;
	selUnit = su;
	pathFinder->DoUnitMaxDistanceTravel(players[curPlayer].GetUnit(selUnit),10);

}



bool Game::getCharacterAt(int cx, int cy, int& sPlayer, int& sUnit)
{
	int pnum = 0;
	int unum = 0;
	for (auto iplayer : players) {
		for (auto unit : iplayer.GetUnits()) {
			if ((unit.GetX() == cx) && (unit.GetY() == cy)) {
				sPlayer = pnum;
				sUnit = unum;
				return true;
			}
			unum++;
		}
		pnum++;
	}
	return false;
}

//This has to be static unless we want to pass 100K vars around.
//Each action, when it closes, adds an action.
void Game::addAction(Action* action, Action* ref)
{
	if (ref == nullptr) {
		gameInstance->actions.push_back(action);
	}/*
	else {
		for (int i = 0; i < gameInstance->actions.size(); i++) {
			if 
		}
		if (gameInstance->actions.find(ref) != gameInstance->end()) {
			//insert before 

		}
	}*/
}

//static
void Game::Create()
{
	gameInstance = new Game();
}

//static
void Game::ProcessEvents()
{
	SDL_Event e;
	while (SDL_PollEvent(&e))
	{
		if (e.type == SDL_QUIT)
		{
			gameInstance->running = false;
		}
	}
}

void Game::Process() {
	last = now;
	now = SDL_GetPerformanceCounter();

	double deltaTime = (double)((now- last)  / (double)SDL_GetPerformanceFrequency());
	//std::cout << "Frame time: " << deltaTime << "\n";
	const uint8_t* ks = SDL_GetKeyboardState(NULL);
	if (ks[SDL_SCANCODE_W]) cy -= 0.001;
	if (ks[SDL_SCANCODE_S]) cy += 0.001;
	if (ks[SDL_SCANCODE_A]) cx -= 0.001;
	if (ks[SDL_SCANCODE_D]) cx += 0.001;

	size_t size = actions.size();
	if (size > 0) {
		if (actions[size - 1]->Process(deltaTime)) {
			delete actions[size - 1];
			actions.pop_back();
		}
	}
	else {
		//No mouse during action time for now
		handleMouse();
	}
	viewPort.SetCamera(cx, cy);
	viewPort.Update(1);
	SDL_Rect myRect;

	//Don't need to clear anything now
		//Display::Clear(0, 0, 0);
	//Get the background up there.........
	SDL_Texture* tempTex = AssetMgr::GetAll("BKG", myRect);
	SDL_Rect screen = { 0,0,1600,800 };
	SDL_RenderSetClipRect(Display::GetRenderer(), &screen);
	Display::DrawTexture(tempTex, &myRect, &screen);
	//Ref out for mCell*
	//Draw the map
	viewPort.Draw(*gameMap, players, pathFinder);
	//Draw the UI......
}

void Game::StartUp(int x, int y)
{
	gameMap = new Map();
	gameMap->Generate();

	pathFinder = new PathFinder(*gameMap);

	AssetMgr::Load("assets/landscape.png", "LAND");
	AssetMgr::Load("assets/background.png", "BKG");
	AssetMgr::Load("assets/dudes.png", "UNITS");
	AssetMgr::Load("assets/highlights.png", "HIGHLIGHT");
	AssetMgr::Load("assets/font16.png", "FONT16");
		
	//These numbers come from the background image........
	viewPort = ViewPort(325, 75, 1225, 675, 1.0f);
	
	GamePlayer player;
	players.push_back(player);
	curPlayer = 0;
	selUnit = -1; //No unit;
}

void Game::NextPlayer()
{
	curPlayer++;
	curPlayer = curPlayer % players.size();
}

/*private static members*/
Game* Game::gameInstance;

int Game::mCellX = 5;
int Game::mCellY = 5;
#pragma once
#include "map.h"
#include "unit.h"
#include "viewport.h"
#include "pathfind.h"
#include "action.h"

class Game
{
private:
	
	bool running;

	//Camera Location
	double cx = 0;
	double cy = 0;

	Game();
	~Game();

	//Stuff we need for game
	Map* gameMap = nullptr;
	std::vector<GamePlayer> players;
	ViewPort viewPort;

	PathFinder* pathFinder = nullptr;

	int curPlayer = -1;
	int selUnit = -1;

	SDL_Point lastMouseCell{ -1,-1 };
	bool mouseDown;

	std::vector<Action*> actions;

	Uint64 now;
	Uint64 last;
private:
	void handleMouse();
	void click();
	void selectUnit(int sp, int su);
	//Gets the character at cell x,y (not mouse location)
	bool getCharacterAt(int cx, int cy, int& sPlayer, int& sUnit);
public: //static
	static void addAction(Action* action, Action *ref = nullptr);

public:
	static int mCellX, mCellY;
	static Game* gameInstance;
	
	static void Create();
	static void ProcessEvents();
	void Process();
	void StartUp(int x, int y);
	void NextPlayer();
	static inline bool IsRunning() { return gameInstance->running; }
};
#include "pch.h"
#include "gameplayer.h"

GamePlayer::GamePlayer()
{
	for (int i = 0; i < initUnits; i++)
	{
		units.push_back(Unit(((UnitType)i), 10 + rand() % 12, 5 + rand() % 12));
	}
}

std::string GamePlayer::GetJson() {
	std::string result = "{";
	for (int i = 0; i < initUnits; i++)
	{
		result += units[i].GetJson();
		if (i < (initUnits - 1)) result += ",";
		result += "\n";
	}
	result += "}\n";
	return result;
}#pragma once
#include "pch.h"
#include "unit.h"

class GamePlayer {
private:
	std::vector<Unit> units;
	//temp
	static constexpr int initUnits = 4;

public:
	GamePlayer();
	std::string GetJson();
	inline std::vector<Unit>& GetUnits()  { return units; }
	inline Unit& GetUnit(int idx) { return units[idx]; }
};
#include "pch.h"
#include "display.h"
#include "game.h"
#include "perlinmap.h"
#include <SDL_image.h>
#include "assetmgr.h"
#include "map.h"
#include "viewport.h"
#include "easywsclient.hpp"

#ifdef _WIN32
#pragma comment( lib, "ws2_32" )
#include <WinSock2.h>
#endif

#include <assert.h>
#include <stdio.h>
#include <string>
#include <memory>
#include "unit.h"



int nomain2()
{
    using easywsclient::WebSocket;
#ifdef _WIN32
    INT rc;
    WSADATA wsaData;
    rc = WSAStartup(MAKEWORD(2, 2), &wsaData);
    if (rc) {
        printf("WSAStartup Failed.\n");
        return 1;
    }
#endif
    

    //XXXC CRW need to thread this, thread safe queue for send/recv

    GamePlayer gp;
    std::unique_ptr<WebSocket> ws(WebSocket::from_url("ws://71.56.75.25:82/chat"));
    assert(ws);
    ws->send("goodbye");
    ws->send("hello");
    while (ws->getReadyState() != WebSocket::CLOSED) {
        WebSocket::pointer wsp = &*ws; // <-- because a unique_ptr cannot be copied into a lambda
        ws->poll();
        ws->dispatch([wsp,&gp](const std::string& message) {
            printf(">>> %s\n", message.c_str());
            if (message == "world") { wsp->close(); }

            //XXXC some bullshit.....
            //we got a message, lets reply with status
            std::string wtf = gp.GetJson();
            wsp->send(wtf);
            });
    }
#ifdef _WIN32
    WSACleanup();
#endif
    // N.B. - unique_ptr will free the WebSocket instance upon return:
    return 0;
}


int main(int argc, char* argv[])
{
    nomain2();
	if (SDL_Init(SDL_INIT_EVERYTHING) != 0)
	{
		std::cout << "Failed to init SDL " << SDL_GetError() << "\n";
		return -1;
	}
	

	Game::Create();
	Display::Create(1600, 800);
	IMG_Init(IMG_INIT_PNG);

	Game::gameInstance->StartUp(1600, 800);

	while (Game::IsRunning())
	{
		Game::ProcessEvents();
		Game::gameInstance->Process();
		Display::Present();
		SDL_Delay(11);
	}
	AssetMgr::Destroy();
	SDL_Quit();
	return 0;
}
#include "pch.h"
#include "map.h"
#include "perlinmap.h"

Map::Map()
{

}

void Map::Generate()
{
	PerlinMap noise(Size,Size);
	noise.Randomize(400000);
	noise.MakePerlin();
	noise.Normalize();

	for (int y = 0; y < Size; y++) {
		for (int x = 0; x < Size; x++) {
			int val =noise.GetTerrain(x, y, 9);
			
			map[y][x] = MapTile(val);
		}
	}

}

int Map::get(int x, int y)
{

	int val = map[y][x].GetTestCellVal();
	return val;
	
}

MapTile& Map::Get(int x, int y)
{
	return map[x][y];
}

#pragma once

#include "maptile.h"

class Map {
public:
	friend class PathFind;
	static constexpr int Size = 128;  //Need a power of 2......
	static constexpr int TileSize = 64;
private:
	MapTile map[Size][Size];
public:
	Map();
	void Generate();
	int get(int x, int y);
	MapTile& Get(int x, int y);
	//Stuff to get/set later
	bool highlighted = false;
};
#include "pch.h"
#include "maptile.h"
#include "assetmgr.h"
#include "map.h"
#include "unit.h"
#include "gameplayer.h"

int MapTile::getSpeed()
{

	switch (type) {
	case MapCellType::MARSH: return 3;
	case MapCellType::GRASS: return 1;
	case MapCellType::STEPPE: return 2;
	case MapCellType::HILL: return 7;
	case MapCellType::ROCKY: return 14;
	case MapCellType::DESTROYED: return 3;
	}
	//Impassable land...
	return 255;
}

MapTile::MapTile()
{

}

//Will have to figure out how to make it prettier
MapTile::MapTile(int val)
{
	imgOffset = rand() % 8;
	type = (MapCellType) val;
	speed = getSpeed();
}

MapTile::MapTile(MapCellType type)
{
	//this will work for now.....
	imgOffset = rand() % 8;
	this->type = type;
	speed = getSpeed();
}

void MapTile::Draw(SDL_Rect dest)
{
	SDL_Rect myRect;
	SDL_Texture* tempTex = AssetMgr::Get("LAND", Map::TileSize, imgOffset,(int) type, myRect);
	Display::DrawTexture(tempTex, &myRect, &dest);
	if (selected) {
		SDL_Texture* highlightTex = AssetMgr::Get("HIGHLIGHT", Map::TileSize, 0, 0, myRect);
		Display::DrawTexture(highlightTex, &myRect, &dest);

		//SDL_Texture* dude = AssetMgr::Get("UNITS", Map::TileSize, 0, 2, myRect);
		//Display::DrawTexture(dude, &myRect, &dest);
		
		//Unit dude(UnitType::Warrior);
		//dude.Draw(dest);

		GamePlayer myPlayer;
		myPlayer.GetUnits();
		
	}
}
#pragma once
#include "pch.h"

enum class MapCellType {
	DEEP_SEA = 0,
	WATER,
	SHALLOW_WATER,
	MARSH,
	GRASS,
	STEPPE,
	HILL,
	ROCKY,
	SNOW,
	NONE,
	DESTROYED
};

//This is a location on the map, stored inside the map
class MapTile {
private:
	MapCellType type = MapCellType::NONE;
	int imgOffset = 0;
	friend class PathFind;
	int speed = 99;
	int getSpeed();
public:
	bool selected = false;
	MapTile();
	MapTile(int val);
	MapTile(MapCellType type);
	void Draw(SDL_Rect dest);
	inline int GetTestCellVal() { return (int)type; }
	inline int GetTestCellOfs() { return imgOffset; }
	inline int GetSpeed() { return speed; }

};
#include "pch.h"
#include "pathfind.h"
#include <set>



PathFinder::PathFinder(Map& imap) : map(imap)
{
	dRange = new std::array<std::array<int, Map::Size>, Map::Size>();
}

void PathFinder::DoUnitMaxDistanceTravel(const Unit& who, int val)
{
	ResetMap();
	calcFlood(who.GetX(),who.GetY(),who.GetSpeed());
}

void PathFinder::DoUnitMaxDistanceAttack(const Unit& who, int val, bool aerial)
{

}

int PathFinder::GetRange(int x, int y)
{
	return (*dRange)[y][x];
}

void PathFinder::ResetMap()
{
	for (int y = 0; y < Map::Size; y++) {
		for (int x = 0; x < Map::Size; x++) {
			//These are just other ways to access it...
			//dMap->at(j).at(i) = -1;
			//dMap->at(j)[i] = -1;
			//(*dMap)[y][x] = -1;
			(*dRange)[y][x] = -1;
		}
	}
}

PathFinder::xyRange PathFinder::pathGood(int x, int y)
{
	int d = ((*dRange)[y][x]);
	if (d < 0) d = Map::Size*2+1;
	return xyRange{ x,y,d };
}

/// <summary>
/// Get path to starts at x, y, and ends at pathfinder 0.  
/// This shall not be called if a path is not already possible.
/// </summary>
/// <param name="x">target x cell</param>
/// <param name="y">targer y cell</param>
/// <returns></returns>
std::vector<SDL_Point> PathFinder::GetPathTo(int x, int y)
{
	int sx = x;
	int sy = y;
	typedef std::tuple<int, int, int> xyRange;
	std::list<xyRange> found;

	std::vector<SDL_Point> thePath;
	//This is out starting location.
	
	thePath.push_back(SDL_Point{ x,y });

	//It's zero when we find the target
	while ((*dRange)[y][x] > 1)
	{
		int d = (*dRange)[y][x];

		std::cout << "Pos" << x << "," << y << " Dist: " << d << "\n";

		found.push_back(pathGood(x, y - 1));
		found.push_back(pathGood(x, y + 1));
		found.push_back(pathGood(x - 1, y));
		found.push_back(pathGood(x + 1, y));

		found.sort([]( xyRange& a, xyRange& b) {
			return std::get<2>(a) < std::get<2>(b); 
			});

		int d1;
		std::tie(x, y, d1) = found.front();

		d = d1;
		found.clear();
		//thePath.insert(thePath.begin(), SDL_Point{ x,y });
		thePath.push_back( SDL_Point{ x,y });
		if (thePath.size() > 20) {
			int bp = 0;
		}
	}
	return thePath;
}

bool PathFinder::rangeOpen(int x, int y, int& speed)
{
	speed = 255;
	if (x < 0) return false;
	if (y < 0) return false;
	if (x >= Map::Size) return false;
	if (y >= Map::Size) return false;
	speed = map.Get(x, y).GetSpeed();
	if (speed < 99) {
		int bp = 0;
	}
	//if (((*dMap)[x][y]) != 0) return false;
	if (((*dRange)[y][x]) == -1) return true;
	return false;

}

void PathFinder::calcFlood(int x, int y, int maxSpeed)
{
	typedef std::tuple<int, int, int> xyRange;
	std::set<xyRange> found;
	found.insert(xyRange(x, y, 1));
	int speed = 0;
	while (found.size() > 0)
	{
		std::set<xyRange> mainSet;
		int sx, sy, d;
		for (xyRange xyz : found) {
			std::tie(sx, sy, d) = xyz;
			//Set this spot.
			(*dRange)[sy][sx] = d;
			if (rangeOpen(sx, sy - 1, speed)) mainSet.insert(xyRange(sx, sy - 1, d + speed));
			if (rangeOpen(sx, sy + 1, speed)) mainSet.insert(xyRange(sx, sy + 1, d + speed));
			if (rangeOpen(sx + 1, sy, speed)) mainSet.insert(xyRange(sx + 1, sy, d + speed));
			if (rangeOpen(sx - 1, sy, speed)) mainSet.insert(xyRange(sx - 1, sy, d + speed));
		}
		found.clear();
		for (xyRange xy : mainSet) {
			std::tie(sx, sy, d) = xy;
			bool isFound = false;
			//Figure out if that position is already found, we don't want to search 2-20x.
			//double searching makes bad paths.
			for (auto position : found) {
				int isx, isy, isd;
				std::tie(isx, isy, isd) = position;
				if ((sx == isx) && (sy == isy)) {
					isFound = true;
					break;
				}
			}
			if (!isFound) {
				//Check our max speed now
				if (d <= maxSpeed) {
					found.insert(xy);
				}
			}
			else {
				int bp = 0;
			}
		}
		mainSet.clear();
	}
}

PathFinder::~PathFinder()
{
	delete dRange;
}#pragma once

#include "pch.h"
#include "maptile.h"
#include "map.h"
#include <vector>
#include "unit.h"



class PathFinder {
private:
    typedef std::tuple<int, int, int> xyRange;

    std::array<std::array<int, Map::Size>, Map::Size>* dRange = nullptr;
    std::vector<SDL_Point> path;
    
    void calcFlood(int x, int y, int maxSpeed);
    bool rangeOpen(int x, int y, int &speed);
    Map& map;
    xyRange pathGood(int x, int y);
public:
    PathFinder(Map& map);
    void DoUnitMaxDistanceTravel(const Unit& who, int val);
    void DoUnitMaxDistanceAttack(const Unit& who, int val, bool aerial);
    void ResetMap();

    

    //Current unit is selected, so this should be simple....
    std::vector<SDL_Point> GetPathTo(int x, int y);

    
    /// <summary>
    /// Returns the distance from calculated path.
    /// </summary>
    /// <param name="x"></param>
    /// <param name="y"></param>
    /// <returns>Returns the distance from calculated path.</returns>
    int GetRange(int x, int y);
    
    ~PathFinder();
};
#include "pch.h"#pragma once

#include <array>
#include <list>
#include <string>
#include <vector>
   
#include <iostream>
#include <sstream>
#include <fstream>

#include <functional>
#include <memory>
#include <map>

#include <SDL.h>
#pragma once
#include "pch.h"
#include "perlinmap.h"
#include <random>
#include "display.h"

PerlinMap::PerlinMap(int x, int y)
{
	width = x;
	height = y;

	evalues = new float[(size_t)x * y];
	svalues = new float[(size_t)x * y];
}

PerlinMap::~PerlinMap()
{
    if (svalues) delete[] svalues;
    if (evalues) delete[] evalues;
}

void PerlinMap::MakePerlin()
{
	float fbias = 2.0f;
	for (int x = 0; x < width; x++) {
		for (int y = 0; y < height; y++)
		{
			float fNoise = 0.0f;
			float fScaleAcc = 0.0f;
			float fScale = 1.0f;

			for (int o = 0; o < (octaves-1); o++)
			{
				int nPitch = width >> o;
				int nSampleX1 = (x / nPitch) * nPitch;
				int nSampleY1 = (y / nPitch) * nPitch;

				int nSampleX2 = (nSampleX1 + nPitch) % width;
				int nSampleY2 = (nSampleY1 + nPitch) % width;

				float fBlendX = (float)(x - nSampleX1) / (float)nPitch;
				float fBlendY = (float)(y - nSampleY1) / (float)nPitch;

				float fSampleT = (1.0f - fBlendX) * svalues[nSampleY1 * width + nSampleX1] + fBlendX * svalues[nSampleY1 * width + nSampleX2];
				float fSampleB = (1.0f - fBlendX) * svalues[nSampleY2 * width + nSampleX1] + fBlendX * svalues[nSampleY2 * width + nSampleX2];

				fScaleAcc += fScale;
				fNoise += (fBlendY * (fSampleB - fSampleT) + fSampleT) * fScale;
				fScale = fScale / fbias;
			}
			// Scale it
			evalues[y * width + x] = fNoise / fScaleAcc;
		}
	}
}

void PerlinMap::Normalize()
{
	float max = -100.0f;
	float min = 100.0f;
	for (int i = 0; i < (width * height); i++) {
		if (evalues[i] > max) max = evalues[i];
		if (evalues[i] < min) min = evalues[i];
	}
	float diff = max - min;
	float mult = 1 / diff;
	for (int i = 0; i < (width * height); i++) {
		evalues[i] -= min;
		evalues[i] *= mult;
	}
}



int PerlinMap::GetTerrain(int x, int y, int max)
{
	//Scale to requested level
	int val = (int)(evalues[y * width + x] * max);

	if (val < 0) val = 0;
	if (val >= max) val = max - 1;
	return val;
}

//static
void PerlinMap::TestDraw()
{
	/*
	int w = 512;
	int h = 512;
	int rval = rand() % 500;
	PerlinMap map = PerlinMap(w, h);
	map.Randomize(107);
	map.MakePerlin();
	map.Normalize();
	SDL_Renderer* ren = Display::GetRenderer();
	//now to draw it.........   ugh
	for (int y = 0; y < h; y++) {
		for (int x = 0; x < w; x++) {
			int val = map.GetTerrain(x, y, 8) * 32;
			if (val > 255) val = 255;
			if (val < 0) val = 0;
			SDL_SetRenderDrawColor(ren, val, val, val, 255);
			SDL_RenderDrawPoint(ren, x, y);
		}
	}
	*/
}

void PerlinMap::Randomize(int iseed)
{
    std::mt19937 gen(iseed);
    std::uniform_real_distribution<> dis(0.0, 1.0);
    for (int x = 0; x < width; x++) {
        for (int y = 0; y < height; y++) {
            svalues[y * width + x] = dis(gen);
        }
    }
}

#pragma once



/// <summary>
/// Do not use new on this.  Just put it on the stack.  Loop through until paths are verified, then go out of scope.
/// </summary>
class PerlinMap {
private:
	int seed = 0;
	int width = 0;
	int height = 0;
	float* svalues = nullptr;
	float* evalues = nullptr;
	const int octaves = 6;
public:
	PerlinMap(int x, int y);
	~PerlinMap();
	/// <summary>
	/// Randomizes the source numbers, taking a new seed - if 
	/// </summary>
	void Randomize(int seed);
	void MakePerlin();
	void Normalize();
	//this will be enum soon
	int GetTerrain(int x, int y, int max);
	static void TestDraw();
};#pragma once

#include <queue>
#include <mutex>
#include <condition_variable>

// A threadsafe-queue.
template <class T>
class ThreadQueue
{
public:
    ThreadQueue(void)
        : q()
        , m()
        , c()
    {}

    ~ThreadQueue(void)
    {}

    // Add an element to the queue.
    void enqueue(T t)
    {
        std::lock_guard<std::mutex> lock(m);
        q.push(t);
        c.notify_one();
    }
    // Get the "front"-element.
    // If the queue is empty, wait till a element is avaiable.
    T dequeue(void)
    {
        std::unique_lock<std::mutex> lock(m);
        while (q.empty())
        {
            // release lock as long as the wait and reaquire it afterwards.
            c.wait(lock);
        }
        T val = q.front();
        q.pop();
        return val;
    }
private:
    std::queue<T> q;
    mutable std::mutex m;
    std::condition_variable c;
};
#include "pch.h"
#include "action.h"


bool ActionPlayLocal::Process(double time)
{
    return false;
}

void ActionPlayLocal::Click()
{
}

ActionMovePlayer::ActionMovePlayer(Unit& who, int x, int y): actor(who)
{
    tx = x;
    ty = y;
}

bool ActionMovePlayer::Process(double time)
{
    float dx = tx - actor.GetXF();
    float dy = ty - actor.GetYF();
    double l = sqrt(dx * dx + dy * dy);
    dx /= l; 
    dy /= l;
    actor.MoveF(actor.GetXF() + dx*time*4, actor.GetYF() + dy*time*4);
    if (l < 0.05) {
        actor.Move(tx, ty);
        return true;
    }
    return false;
}

void ActionMovePlayer::Click()
{
}

Action::Action()
{
}
#include "pch.h"
#include "unit.h"


class Action {
public:
	//Returns true if Process is complete.
	virtual bool Process(double time) = 0;
	virtual void Click() = 0;
	Action();
	
};

class ActionPlayLocal : public Action {
	bool Process(double time);
	void Click();
};



class ActionMovePlayer : public Action {
	int tx, ty;
	Unit& actor;
public:
	ActionMovePlayer(Unit& who, int x, int y);
	bool Process(double time);
	void Click();
};


//XXXC CRW  Need action request, action join, action waiting, action playing and action 
//game over.  Also have to do point inserts on action lists.
#include "pch.h"
#include "animation.h"
#pragma once

class Animation
{
private:

public:
	virtual ~Animation() = default;

	virtual void Start() = 0;
};

class AnimationArrow : public Animation
{
private:
public:
};#pragma once
#include "pch.h"
#include "assetmgr.h"


void AssetMgr::Destroy()
{
	for (auto i : AssetMgr::Images) SDL_DestroyTexture(i.second);
}

bool AssetMgr::Load(std::string filename, std::string nick)
{
	SDL_Texture* texture = IMG_LoadTexture(Display::GetRenderer(), filename.c_str());
	Images[nick] = texture;
	return false;
}

SDL_Texture* AssetMgr::Get(std::string nick, int gridSize, int x, int y, SDL_Rect& dest) {
	SDL_Texture* tex = Images[nick];
	if (tex == nullptr) return tex;
	dest.x = gridSize * x;
	dest.y = gridSize * y;
	dest.w = gridSize;
	dest.h = gridSize;
	return tex;
}

SDL_Texture* AssetMgr::GetAll(std::string nick, SDL_Rect& dest)
{
	SDL_Texture* tex = Images[nick];
	Uint32 fmt;
	int acs;
	dest.x = 0;
	dest.y = 0;
	SDL_QueryTexture(tex, &fmt, &acs, &dest.w, &dest.h);
		
	return tex;
}


//Statics
std::map<std::string, SDL_Texture*> AssetMgr::Images;
#pragma once
#include "pch.h"
#include "display.h"
#include "SDL_image.h"

class AssetMgr {
private:
	
	
	
public:
	static void Destroy();
	static std::map<std::string, SDL_Texture*> Images;
	static bool Load(std::string filename, std::string nick);
	static SDL_Texture* Get(std::string nick, int gridSize, int x, int y, SDL_Rect& dest);
	static SDL_Texture* GetAll(std::string nick, SDL_Rect& dest);
};

clear
g++ -I/usr/include/SDL2 -I. game.cpp assetmgr.cpp pathfind.cpp map.cpp unit.cpp gameplayer.cpp viewport.cpp perlinmap.cpp display.cpp maptile.cpp main.cpp -o main `sdl2-config --cflags --libs` -lSDL2 -lSDL2_image
./main

#include "pch.h"
#include "display.h"

Display::Display(int width, int height)
	: window(nullptr), renderer(nullptr), width(width), height(height)
{
	if (SDL_CreateWindowAndRenderer(width, height, 0, &window, &renderer) < 0)
	{
		std::cout << "Failed to create display: " << SDL_GetError() << "\n";
	}
}

Display::~Display()
{
	SDL_DestroyRenderer(renderer);
	SDL_DestroyWindow(window);

	delete displayInstance;
}

void Display::Create(int width, int height)
{
	displayInstance = new Display(width, height);
}

void Display::Clear(Uint8 r, Uint8 g, Uint8 b)
{
	SDL_SetRenderDrawColor(GetRenderer(), r, g, b, 255);
	SDL_RenderClear(GetRenderer());
}

void Display::Present()
{
	SDL_RenderPresent(GetRenderer());
}

void Display::DrawTexture(SDL_Texture* texture)
{
	SDL_RenderCopy(GetRenderer(), texture, nullptr, nullptr);
}

void Display::DrawTexture(SDL_Texture* texture, const SDL_Rect* targetRect)
{
	SDL_RenderCopy(GetRenderer(), texture, nullptr, targetRect);
}

void Display::DrawTexture(SDL_Texture* texture, const SDL_Rect* targetRect, const SDL_Rect* subTexture)
{
	SDL_RenderCopy(GetRenderer(), texture, targetRect, subTexture);
}

/*Static members*/
Display* Display::displayInstance;

SDL_ClipRectSection::SDL_ClipRectSection(int x, int y, int w, int h)
{
	SDL_RenderGetClipRect(Display::GetRenderer(), &oldRect);
	SDL_Rect clip= { x,y,w,h };
	SDL_RenderSetClipRect(Display::GetRenderer(), &clip);
}

SDL_ClipRectSection::~SDL_ClipRectSection()
{
	SDL_RenderSetClipRect(Display::GetRenderer(), &oldRect);
}
#pragma once
#include "pch.h"

class Display
{
private:
	static Display* displayInstance;

	SDL_Window* window;
	SDL_Renderer* renderer;

	int width;
	int height;

	Display(int width, int height);
	~Display();

public:

	static void Create(int width, int height);

	static void Clear(Uint8 r, Uint8 g, Uint8 b);
	static void Present();
	
	static void DrawTexture(SDL_Texture* texture);
	static void DrawTexture(SDL_Texture* texture, const SDL_Rect* targetRect);
	static void DrawTexture(SDL_Texture* texture, const SDL_Rect* targetRect, const SDL_Rect* subTexture);

	static inline SDL_Window* GetWindow() { return displayInstance->window; }
	static inline SDL_Renderer* GetRenderer() { return displayInstance->renderer; }
};


class SDL_ClipRectSection {
	SDL_Rect oldRect;
public:
	SDL_ClipRectSection(int x, int y, int w, int h);
	~SDL_ClipRectSection(); 
};#include "pch.h"
#ifdef _WIN32
    #if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)
        #define _CRT_SECURE_NO_WARNINGS // _CRT_SECURE_NO_WARNINGS for sscanf errors in MSVC2013 Express
    #endif
    #ifndef WIN32_LEAN_AND_MEAN
        #define WIN32_LEAN_AND_MEAN
    #endif
    #include <fcntl.h>
    #include <WinSock2.h>
    #include <WS2tcpip.h>
    #pragma comment( lib, "ws2_32" )
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>
    #include <sys/types.h>
    #include <io.h>
    #ifndef _SSIZE_T_DEFINED
        typedef int ssize_t;
        #define _SSIZE_T_DEFINED
    #endif
    #ifndef _SOCKET_T_DEFINED
        typedef SOCKET socket_t;
        #define _SOCKET_T_DEFINED
    #endif
    #ifndef snprintf
        #define snprintf _snprintf_s
    #endif
    #if _MSC_VER >=1600
        // vs2010 or later
        #include <stdint.h>
    #else
        typedef __int8 int8_t;
        typedef unsigned __int8 uint8_t;
        typedef __int32 int32_t;
        typedef unsigned __int32 uint32_t;
        typedef __int64 int64_t;
        typedef unsigned __int64 uint64_t;
    #endif
    #define socketerrno WSAGetLastError()
    #define SOCKET_EAGAIN_EINPROGRESS WSAEINPROGRESS
    #define SOCKET_EWOULDBLOCK WSAEWOULDBLOCK
#else
    #include <fcntl.h>
    #include <netdb.h>
    #include <netinet/tcp.h>
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>
    #include <sys/socket.h>
    #include <sys/time.h>
    #include <sys/types.h>
    #include <unistd.h>
    #include <stdint.h>
    #ifndef _SOCKET_T_DEFINED
        typedef int socket_t;
        #define _SOCKET_T_DEFINED
    #endif
    #ifndef INVALID_SOCKET
        #define INVALID_SOCKET (-1)
    #endif
    #ifndef SOCKET_ERROR
        #define SOCKET_ERROR   (-1)
    #endif
    #define closesocket(s) ::close(s)
    #include <errno.h>
    #define socketerrno errno
    #define SOCKET_EAGAIN_EINPROGRESS EAGAIN
    #define SOCKET_EWOULDBLOCK EWOULDBLOCK
#endif

#include <vector>
#include <string>

#include "easywsclient.hpp"

using easywsclient::Callback_Imp;
using easywsclient::BytesCallback_Imp;

namespace { // private module-only namespace

socket_t hostname_connect(const std::string& hostname, int port) {
    struct addrinfo hints;
    struct addrinfo *result;
    struct addrinfo *p;
    int ret;
    socket_t sockfd = INVALID_SOCKET;
    char sport[16];
    memset(&hints, 0, sizeof(hints));
    hints.ai_family = AF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;
    snprintf(sport, 16, "%d", port);
    if ((ret = getaddrinfo(hostname.c_str(), sport, &hints, &result)) != 0)
    {
      fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(ret));
      return 1;
    }
    for(p = result; p != NULL; p = p->ai_next)
    {
        sockfd = socket(p->ai_family, p->ai_socktype, p->ai_protocol);
        if (sockfd == INVALID_SOCKET) { continue; }
        if (connect(sockfd, p->ai_addr, p->ai_addrlen) != SOCKET_ERROR) {
            break;
        }
        closesocket(sockfd);
        sockfd = INVALID_SOCKET;
    }
    freeaddrinfo(result);
    return sockfd;
}


class _DummyWebSocket : public easywsclient::WebSocket
{
  public:
    void poll(int timeout) { }
    void send(const std::string& message) { }
    void sendBinary(const std::string& message) { }
    void sendBinary(const std::vector<uint8_t>& message) { }
    void sendPing() { }
    void close() { } 
    readyStateValues getReadyState() const { return CLOSED; }
    void _dispatch(Callback_Imp & callable) { }
    void _dispatchBinary(BytesCallback_Imp& callable) { }
};


class _RealWebSocket : public easywsclient::WebSocket
{
  public:
    // http://tools.ietf.org/html/rfc6455#section-5.2  Base Framing Protocol
    //
    //  0                   1                   2                   3
    //  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    // +-+-+-+-+-------+-+-------------+-------------------------------+
    // |F|R|R|R| opcode|M| Payload len |    Extended payload length    |
    // |I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |
    // |N|V|V|V|       |S|             |   (if payload len==126/127)   |
    // | |1|2|3|       |K|             |                               |
    // +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +
    // |     Extended payload length continued, if payload len == 127  |
    // + - - - - - - - - - - - - - - - +-------------------------------+
    // |                               |Masking-key, if MASK set to 1  |
    // +-------------------------------+-------------------------------+
    // | Masking-key (continued)       |          Payload Data         |
    // +-------------------------------- - - - - - - - - - - - - - - - +
    // :                     Payload Data continued ...                :
    // + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
    // |                     Payload Data continued ...                |
    // +---------------------------------------------------------------+
    struct wsheader_type {
        unsigned header_size;
        bool fin;
        bool mask;
        enum opcode_type {
            CONTINUATION = 0x0,
            TEXT_FRAME = 0x1,
            BINARY_FRAME = 0x2,
            CLOSE = 8,
            PING = 9,
            PONG = 0xa,
        } opcode;
        int N0;
        uint64_t N;
        uint8_t masking_key[4];
    };

    std::vector<uint8_t> rxbuf;
    std::vector<uint8_t> txbuf;
    std::vector<uint8_t> receivedData;

    socket_t sockfd;
    readyStateValues readyState;
    bool useMask;
    bool isRxBad;

    _RealWebSocket(socket_t sockfd, bool useMask)
            : sockfd(sockfd)
            , readyState(OPEN)
            , useMask(useMask)
            , isRxBad(false) {
    }

    readyStateValues getReadyState() const {
      return readyState;
    }

    void poll(int timeout) { // timeout in milliseconds
        if (readyState == CLOSED) {
            if (timeout > 0) {
                timeval tv = { timeout/1000, (timeout%1000) * 1000 };
                select(0, NULL, NULL, NULL, &tv);
            }
            return;
        }
        if (timeout != 0) {
            fd_set rfds;
            fd_set wfds;
            timeval tv = { timeout/1000, (timeout%1000) * 1000 };
            FD_ZERO(&rfds);
            FD_ZERO(&wfds);
            FD_SET(sockfd, &rfds);
            if (txbuf.size()) { FD_SET(sockfd, &wfds); }
            select(sockfd + 1, &rfds, &wfds, 0, timeout > 0 ? &tv : 0);
        }
        while (true) {
            // FD_ISSET(0, &rfds) will be true
            int N = rxbuf.size();
            ssize_t ret;
            rxbuf.resize(N + 1500);
            ret = recv(sockfd, (char*)&rxbuf[0] + N, 1500, 0);
            if (false) { }
            else if (ret < 0 && (socketerrno == SOCKET_EWOULDBLOCK || socketerrno == SOCKET_EAGAIN_EINPROGRESS)) {
                rxbuf.resize(N);
                break;
            }
            else if (ret <= 0) {
                rxbuf.resize(N);
                closesocket(sockfd);
                readyState = CLOSED;
                fputs(ret < 0 ? "Connection error!\n" : "Connection closed!\n", stderr);
                break;
            }
            else {
                rxbuf.resize(N + ret);
            }
        }
        while (txbuf.size()) {
            int ret = ::send(sockfd, (char*)&txbuf[0], txbuf.size(), 0);
            if (false) { } // ??
            else if (ret < 0 && (socketerrno == SOCKET_EWOULDBLOCK || socketerrno == SOCKET_EAGAIN_EINPROGRESS)) {
                break;
            }
            else if (ret <= 0) {
                closesocket(sockfd);
                readyState = CLOSED;
                fputs(ret < 0 ? "Connection error!\n" : "Connection closed!\n", stderr);
                break;
            }
            else {
                txbuf.erase(txbuf.begin(), txbuf.begin() + ret);
            }
        }
        if (!txbuf.size() && readyState == CLOSING) {
            closesocket(sockfd);
            readyState = CLOSED;
        }
    }

    // Callable must have signature: void(const std::string & message).
    // Should work with C functions, C++ functors, and C++11 std::function and
    // lambda:
    //template<class Callable>
    //void dispatch(Callable callable)
    virtual void _dispatch(Callback_Imp & callable) {
        struct CallbackAdapter : public BytesCallback_Imp
            // Adapt void(const std::string<uint8_t>&) to void(const std::string&)
        {
            Callback_Imp& callable;
            CallbackAdapter(Callback_Imp& callable) : callable(callable) { }
            void operator()(const std::vector<uint8_t>& message) {
                std::string stringMessage(message.begin(), message.end());
                callable(stringMessage);
            }
        };
        CallbackAdapter bytesCallback(callable);
        _dispatchBinary(bytesCallback);
    }

    virtual void _dispatchBinary(BytesCallback_Imp & callable) {
        // TODO: consider acquiring a lock on rxbuf...
        if (isRxBad) {
            return;
        }
        while (true) {
            wsheader_type ws;
            if (rxbuf.size() < 2) { return; /* Need at least 2 */ }
            const uint8_t * data = (uint8_t *) &rxbuf[0]; // peek, but don't consume
            ws.fin = (data[0] & 0x80) == 0x80;
            ws.opcode = (wsheader_type::opcode_type) (data[0] & 0x0f);
            ws.mask = (data[1] & 0x80) == 0x80;
            ws.N0 = (data[1] & 0x7f);
            ws.header_size = 2 + (ws.N0 == 126? 2 : 0) + (ws.N0 == 127? 8 : 0) + (ws.mask? 4 : 0);
            if (rxbuf.size() < ws.header_size) { return; /* Need: ws.header_size - rxbuf.size() */ }
            int i = 0;
            if (ws.N0 < 126) {
                ws.N = ws.N0;
                i = 2;
            }
            else if (ws.N0 == 126) {
                ws.N = 0;
                ws.N |= ((uint64_t) data[2]) << 8;
                ws.N |= ((uint64_t) data[3]) << 0;
                i = 4;
            }
            else if (ws.N0 == 127) {
                ws.N = 0;
                ws.N |= ((uint64_t) data[2]) << 56;
                ws.N |= ((uint64_t) data[3]) << 48;
                ws.N |= ((uint64_t) data[4]) << 40;
                ws.N |= ((uint64_t) data[5]) << 32;
                ws.N |= ((uint64_t) data[6]) << 24;
                ws.N |= ((uint64_t) data[7]) << 16;
                ws.N |= ((uint64_t) data[8]) << 8;
                ws.N |= ((uint64_t) data[9]) << 0;
                i = 10;
                if (ws.N & 0x8000000000000000ull) {
                    // https://tools.ietf.org/html/rfc6455 writes the "the most
                    // significant bit MUST be 0."
                    //
                    // We can't drop the frame, because (1) we don't we don't
                    // know how much data to skip over to find the next header,
                    // and (2) this would be an impractically long length, even
                    // if it were valid. So just close() and return immediately
                    // for now.
                    isRxBad = true;
                    fprintf(stderr, "ERROR: Frame has invalid frame length. Closing.\n");
                    close();
                    return;
                }
            }
            if (ws.mask) {
                ws.masking_key[0] = ((uint8_t) data[i+0]) << 0;
                ws.masking_key[1] = ((uint8_t) data[i+1]) << 0;
                ws.masking_key[2] = ((uint8_t) data[i+2]) << 0;
                ws.masking_key[3] = ((uint8_t) data[i+3]) << 0;
            }
            else {
                ws.masking_key[0] = 0;
                ws.masking_key[1] = 0;
                ws.masking_key[2] = 0;
                ws.masking_key[3] = 0;
            }

            // Note: The checks above should hopefully ensure this addition
            //       cannot overflow:
            if (rxbuf.size() < ws.header_size+ws.N) { return; /* Need: ws.header_size+ws.N - rxbuf.size() */ }

            // We got a whole message, now do something with it:
            if (false) { }
            else if (
                   ws.opcode == wsheader_type::TEXT_FRAME 
                || ws.opcode == wsheader_type::BINARY_FRAME
                || ws.opcode == wsheader_type::CONTINUATION
            ) {
                if (ws.mask) { for (size_t i = 0; i != ws.N; ++i) { rxbuf[i+ws.header_size] ^= ws.masking_key[i&0x3]; } }
                receivedData.insert(receivedData.end(), rxbuf.begin()+ws.header_size, rxbuf.begin()+ws.header_size+(size_t)ws.N);// just feed
                if (ws.fin) {
                    callable((const std::vector<uint8_t>) receivedData);
                    receivedData.erase(receivedData.begin(), receivedData.end());
                    std::vector<uint8_t> ().swap(receivedData);// free memory
                }
            }
            else if (ws.opcode == wsheader_type::PING) {
                if (ws.mask) { for (size_t i = 0; i != ws.N; ++i) { rxbuf[i+ws.header_size] ^= ws.masking_key[i&0x3]; } }
                std::string data(rxbuf.begin()+ws.header_size, rxbuf.begin()+ws.header_size+(size_t)ws.N);
                sendData(wsheader_type::PONG, data.size(), data.begin(), data.end());
            }
            else if (ws.opcode == wsheader_type::PONG) { }
            else if (ws.opcode == wsheader_type::CLOSE) { close(); }
            else { fprintf(stderr, "ERROR: Got unexpected WebSocket message.\n"); close(); }

            rxbuf.erase(rxbuf.begin(), rxbuf.begin() + ws.header_size+(size_t)ws.N);
        }
    }

    void sendPing() {
        std::string empty;
        sendData(wsheader_type::PING, empty.size(), empty.begin(), empty.end());
    }

    void send(const std::string& message) {
        sendData(wsheader_type::TEXT_FRAME, message.size(), message.begin(), message.end());
    }

    void sendBinary(const std::string& message) {
        sendData(wsheader_type::BINARY_FRAME, message.size(), message.begin(), message.end());
    }

    void sendBinary(const std::vector<uint8_t>& message) {
        sendData(wsheader_type::BINARY_FRAME, message.size(), message.begin(), message.end());
    }

    template<class Iterator>
    void sendData(wsheader_type::opcode_type type, uint64_t message_size, Iterator message_begin, Iterator message_end) {
        // TODO:
        // Masking key should (must) be derived from a high quality random
        // number generator, to mitigate attacks on non-WebSocket friendly
        // middleware:
        const uint8_t masking_key[4] = { 0x12, 0x34, 0x56, 0x78 };
        // TODO: consider acquiring a lock on txbuf...
        if (readyState == CLOSING || readyState == CLOSED) { return; }
        std::vector<uint8_t> header;
        header.assign(2 + (message_size >= 126 ? 2 : 0) + (message_size >= 65536 ? 6 : 0) + (useMask ? 4 : 0), 0);
        header[0] = 0x80 | type;
        if (false) { }
        else if (message_size < 126) {
            header[1] = (message_size & 0xff) | (useMask ? 0x80 : 0);
            if (useMask) {
                header[2] = masking_key[0];
                header[3] = masking_key[1];
                header[4] = masking_key[2];
                header[5] = masking_key[3];
            }
        }
        else if (message_size < 65536) {
            header[1] = 126 | (useMask ? 0x80 : 0);
            header[2] = (message_size >> 8) & 0xff;
            header[3] = (message_size >> 0) & 0xff;
            if (useMask) {
                header[4] = masking_key[0];
                header[5] = masking_key[1];
                header[6] = masking_key[2];
                header[7] = masking_key[3];
            }
        }
        else { // TODO: run coverage testing here
            header[1] = 127 | (useMask ? 0x80 : 0);
            header[2] = (message_size >> 56) & 0xff;
            header[3] = (message_size >> 48) & 0xff;
            header[4] = (message_size >> 40) & 0xff;
            header[5] = (message_size >> 32) & 0xff;
            header[6] = (message_size >> 24) & 0xff;
            header[7] = (message_size >> 16) & 0xff;
            header[8] = (message_size >>  8) & 0xff;
            header[9] = (message_size >>  0) & 0xff;
            if (useMask) {
                header[10] = masking_key[0];
                header[11] = masking_key[1];
                header[12] = masking_key[2];
                header[13] = masking_key[3];
            }
        }
        // N.B. - txbuf will keep growing until it can be transmitted over the socket:
        txbuf.insert(txbuf.end(), header.begin(), header.end());
        txbuf.insert(txbuf.end(), message_begin, message_end);
        if (useMask) {
            size_t message_offset = txbuf.size() - message_size;
            for (size_t i = 0; i != message_size; ++i) {
                txbuf[message_offset + i] ^= masking_key[i&0x3];
            }
        }
    }

    void close() {
        if(readyState == CLOSING || readyState == CLOSED) { return; }
        readyState = CLOSING;
        uint8_t closeFrame[6] = {0x88, 0x80, 0x00, 0x00, 0x00, 0x00}; // last 4 bytes are a masking key
        std::vector<uint8_t> header(closeFrame, closeFrame+6);
        txbuf.insert(txbuf.end(), header.begin(), header.end());
    }

};


easywsclient::WebSocket::pointer from_url(const std::string& url, bool useMask, const std::string& origin) {
    char host[512];
    int port;
    char path[512];
    if (url.size() >= 512) {
      fprintf(stderr, "ERROR: url size limit exceeded: %s\n", url.c_str());
      return NULL;
    }
    if (origin.size() >= 200) {
      fprintf(stderr, "ERROR: origin size limit exceeded: %s\n", origin.c_str());
      return NULL;
    }
    if (false) { }
    else if (sscanf_s(url.c_str(), "ws://%[^:/]:%d/%s", host,512, &port, path,512) == 3) {
    }
    else if (sscanf_s(url.c_str(), "ws://%[^:/]/%s", host,512, path, 512) == 2) {
        port = 80;
    }
    else if (sscanf_s(url.c_str(), "ws://%[^:/]:%d", host,512, &port) == 2) {
        path[0] = '\0';
    }
    else if (sscanf_s(url.c_str(), "ws://%[^:/]", host, 512) == 1) {
        port = 80;
        path[0] = '\0';
    }
    else {
        fprintf(stderr, "ERROR: Could not parse WebSocket url: %s\n", url.c_str());
        return NULL;
    }
    //fprintf(stderr, "easywsclient: connecting: host=%s port=%d path=/%s\n", host, port, path);
    socket_t sockfd = hostname_connect(host, port);
    if (sockfd == INVALID_SOCKET) {
        fprintf(stderr, "Unable to connect to %s:%d\n", host, port);
        return NULL;
    }
    {
        // XXX: this should be done non-blocking,
        char line[1024];
        int status;
        int i;
        snprintf(line, 1024, "GET /%s HTTP/1.1\r\n", path); ::send(sockfd, line, strlen(line), 0);
        if (port == 80) {
            snprintf(line, 1024, "Host: %s\r\n", host); ::send(sockfd, line, strlen(line), 0);
        }
        else {
            snprintf(line, 1024, "Host: %s:%d\r\n", host, port); ::send(sockfd, line, strlen(line), 0);
        }
        snprintf(line, 1024, "Upgrade: websocket\r\n"); ::send(sockfd, line, strlen(line), 0);
        snprintf(line, 1024, "Connection: Upgrade\r\n"); ::send(sockfd, line, strlen(line), 0);
        if (!origin.empty()) {
            snprintf(line, 1024, "Origin: %s\r\n", origin.c_str()); ::send(sockfd, line, strlen(line), 0);
        }
        snprintf(line, 1024, "Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==\r\n"); ::send(sockfd, line, strlen(line), 0);
        snprintf(line, 1024, "Sec-WebSocket-Version: 13\r\n"); ::send(sockfd, line, strlen(line), 0);
        snprintf(line, 1024, "\r\n"); ::send(sockfd, line, strlen(line), 0);
        for (i = 0; i < 2 || (i < 1023 && line[i-2] != '\r' && line[i-1] != '\n'); ++i) { if (recv(sockfd, line+i, 1, 0) == 0) { return NULL; } }
        line[i] = 0;
        if (i == 1023) { fprintf(stderr, "ERROR: Got invalid status line connecting to: %s\n", url.c_str()); return NULL; }
        if (sscanf_s(line, "HTTP/1.1 %d", &status) != 1 || status != 101) { fprintf(stderr, "ERROR: Got bad status connecting to %s: %s", url.c_str(), line); return NULL; }
        // TODO: verify response headers,
        while (true) {
            for (i = 0; i < 2 || (i < 1023 && line[i-2] != '\r' && line[i-1] != '\n'); ++i) { if (recv(sockfd, line+i, 1, 0) == 0) { return NULL; } }
            if (line[0] == '\r' && line[1] == '\n') { break; }
        }
    }
    int flag = 1;
    setsockopt(sockfd, IPPROTO_TCP, TCP_NODELAY, (char*) &flag, sizeof(flag)); // Disable Nagle's algorithm
#ifdef _WIN32
    u_long on = 1;
    ioctlsocket(sockfd, FIONBIO, &on);
#else
    fcntl(sockfd, F_SETFL, O_NONBLOCK);
#endif
    //fprintf(stderr, "Connected to: %s\n", url.c_str());
    return easywsclient::WebSocket::pointer(new _RealWebSocket(sockfd, useMask));
}

} // end of module-only namespace



namespace easywsclient {

WebSocket::pointer WebSocket::create_dummy() {
    static pointer dummy = pointer(new _DummyWebSocket);
    return dummy;
}


WebSocket::pointer WebSocket::from_url(const std::string& url, const std::string& origin) {
    return ::from_url(url, true, origin);
}

WebSocket::pointer WebSocket::from_url_no_mask(const std::string& url, const std::string& origin) {
    return ::from_url(url, false, origin);
}


} // namespace easywsclient
#ifndef EASYWSCLIENT_HPP_20120819_MIOFVASDTNUASZDQPLFD
#define EASYWSCLIENT_HPP_20120819_MIOFVASDTNUASZDQPLFD

// This code comes from:
// https://github.com/dhbaird/easywsclient
//
// To get the latest version:
// wget https://raw.github.com/dhbaird/easywsclient/master/easywsclient.hpp
// wget https://raw.github.com/dhbaird/easywsclient/master/easywsclient.cpp

#include <string>
#include <vector>

namespace easywsclient {

struct Callback_Imp { virtual void operator()(const std::string& message) = 0; };
struct BytesCallback_Imp { virtual void operator()(const std::vector<uint8_t>& message) = 0; };

class WebSocket {
  public:
    typedef WebSocket * pointer;
    typedef enum readyStateValues { CLOSING, CLOSED, CONNECTING, OPEN } readyStateValues;

    // Factories:
    static pointer create_dummy();
    static pointer from_url(const std::string& url, const std::string& origin = std::string());
    static pointer from_url_no_mask(const std::string& url, const std::string& origin = std::string());

    // Interfaces:
    virtual ~WebSocket() { }
    virtual void poll(int timeout = 0) = 0; // timeout in milliseconds
    virtual void send(const std::string& message) = 0;
    virtual void sendBinary(const std::string& message) = 0;
    virtual void sendBinary(const std::vector<uint8_t>& message) = 0;
    virtual void sendPing() = 0;
    virtual void close() = 0;
    virtual readyStateValues getReadyState() const = 0;

    template<class Callable>
    void dispatch(Callable callable)
        // For callbacks that accept a string argument.
    { // N.B. this is compatible with both C++11 lambdas, functors and C function pointers
        struct _Callback : public Callback_Imp {
            Callable& callable;
            _Callback(Callable& callable) : callable(callable) { }
            void operator()(const std::string& message) { callable(message); }
        };
        _Callback callback(callable);
        _dispatch(callback);
    }

    template<class Callable>
    void dispatchBinary(Callable callable)
        // For callbacks that accept a std::vector<uint8_t> argument.
    { // N.B. this is compatible with both C++11 lambdas, functors and C function pointers
        struct _Callback : public BytesCallback_Imp {
            Callable& callable;
            _Callback(Callable& callable) : callable(callable) { }
            void operator()(const std::vector<uint8_t>& message) { callable(message); }
        };
        _Callback callback(callable);
        _dispatchBinary(callback);
    }

  protected:
    virtual void _dispatch(Callback_Imp& callable) = 0;
    virtual void _dispatchBinary(BytesCallback_Imp& callable) = 0;
};

} // namespace easywsclient

#endif /* EASYWSCLIENT_HPP_20120819_MIOFVASDTNUASZDQPLFD */
#include "pch.h"
#include "pch.h"
#include "game.h"
#include "assetmgr.h"
#include "viewport.h"
#include "easywsclient.hpp"

/*
#include "websocketpp/config/asio_no_tls_client.hpp"
#include "websocketpp/client.hpp"
*/


//XXXC CRW Need an action for requestion new room, joining room, etc.

Game::Game()
	: running(true)
{

}

Game::~Game()
{
	delete gameInstance;
}

void Game::handleMouse()
{

	int mx, my;
	uint32_t mouseState = SDL_GetMouseState(&mx, &my);
	//Update the hover locations
	viewPort.GetCellAtMouseXY(mx, my, mCellX, mCellY);

	bool tMouseDown = mouseState & SDL_BUTTON_LEFT;
	if (tMouseDown != mouseDown) {   //State changed.
		if (tMouseDown) {
			viewPort.GetCellAtMouseXY(mx, my, lastMouseCell.x, lastMouseCell.y);
		}
		else { //Upclick
			int imx, imy;
			viewPort.GetCellAtMouseXY(mx, my, imx, imy);
			if ((imx == lastMouseCell.x) && (imy = lastMouseCell.y)) {
				click();
				lastMouseCell.x = -1;
				lastMouseCell.y = -1;
			}
		}
		mouseDown = tMouseDown;
	}
}

void Game::click()
{
	int sp, su;
	if (getCharacterAt(lastMouseCell.x, lastMouseCell.y, sp, su)) {
		//We have a character......
		int bp = 0;
		if (sp == curPlayer) {
			if (su != selUnit) {
				selectUnit(sp, su);
			};
		}
	}
	else {
		if (pathFinder->GetRange(lastMouseCell.x, lastMouseCell.y) > -1) {
			//This should be a valid move.
			auto& thisUnit = players[curPlayer].GetUnit(selUnit);
			auto fuckme = pathFinder->GetPathTo(lastMouseCell.x, lastMouseCell.y);
			for (auto me : fuckme) {
				addAction(new ActionMovePlayer(thisUnit, me.x, me.y));
				/*actions.insert(actions.begin(), ActionMovePlayer(thisUnit, me.x, me.y));
				actions.insert()*/
				}
			//thisUnit.Move(lastMouseCell.x, lastMouseCell.y);
			int bp = 0;
		}
		selUnit = -1;
		pathFinder->ResetMap();
	}
}

void Game::selectUnit(int sp, int su)
{
	int bp = 0;
	selUnit = su;
	pathFinder->DoUnitMaxDistanceTravel(players[curPlayer].GetUnit(selUnit),10);

}



bool Game::getCharacterAt(int cx, int cy, int& sPlayer, int& sUnit)
{
	int pnum = 0;
	int unum = 0;
	for (auto iplayer : players) {
		for (auto unit : iplayer.GetUnits()) {
			if ((unit.GetX() == cx) && (unit.GetY() == cy)) {
				sPlayer = pnum;
				sUnit = unum;
				return true;
			}
			unum++;
		}
		pnum++;
	}
	return false;
}

//This has to be static unless we want to pass 100K vars around.
//Each action, when it closes, adds an action.
void Game::addAction(Action* action, Action* ref)
{
	if (ref == nullptr) {
		gameInstance->actions.push_back(action);
	}/*
	else {
		for (int i = 0; i < gameInstance->actions.size(); i++) {
			if 
		}
		if (gameInstance->actions.find(ref) != gameInstance->end()) {
			//insert before 

		}
	}*/
}

//static
void Game::Create()
{
	gameInstance = new Game();
}

//static
void Game::ProcessEvents()
{
	SDL_Event e;
	while (SDL_PollEvent(&e))
	{
		if (e.type == SDL_QUIT)
		{
			gameInstance->running = false;
		}
	}
}

void Game::Process() {
	last = now;
	now = SDL_GetPerformanceCounter();

	double deltaTime = (double)((now- last)  / (double)SDL_GetPerformanceFrequency());
	//std::cout << "Frame time: " << deltaTime << "\n";
	const uint8_t* ks = SDL_GetKeyboardState(NULL);
	if (ks[SDL_SCANCODE_W]) cy -= 0.001;
	if (ks[SDL_SCANCODE_S]) cy += 0.001;
	if (ks[SDL_SCANCODE_A]) cx -= 0.001;
	if (ks[SDL_SCANCODE_D]) cx += 0.001;

	size_t size = actions.size();
	if (size > 0) {
		if (actions[size - 1]->Process(deltaTime)) {
			delete actions[size - 1];
			actions.pop_back();
		}
	}
	else {
		//No mouse during action time for now
		handleMouse();
	}
	viewPort.SetCamera(cx, cy);
	viewPort.Update(1);
	SDL_Rect myRect;

	//Don't need to clear anything now
		//Display::Clear(0, 0, 0);
	//Get the background up there.........
	SDL_Texture* tempTex = AssetMgr::GetAll("BKG", myRect);
	SDL_Rect screen = { 0,0,1600,800 };
	SDL_RenderSetClipRect(Display::GetRenderer(), &screen);
	Display::DrawTexture(tempTex, &myRect, &screen);
	//Ref out for mCell*
	//Draw the map
	viewPort.Draw(*gameMap, players, pathFinder);
	//Draw the UI......
}

void Game::StartUp(int x, int y)
{
	gameMap = new Map();
	gameMap->Generate();

	pathFinder = new PathFinder(*gameMap);

	AssetMgr::Load("assets/landscape.png", "LAND");
	AssetMgr::Load("assets/background.png", "BKG");
	AssetMgr::Load("assets/dudes.png", "UNITS");
	AssetMgr::Load("assets/highlights.png", "HIGHLIGHT");
	AssetMgr::Load("assets/font16.png", "FONT16");
		
	//These numbers come from the background image........
	viewPort = ViewPort(325, 75, 1225, 675, 1.0f);
	
	GamePlayer player;
	players.push_back(player);
	curPlayer = 0;
	selUnit = -1; //No unit;
}

void Game::NextPlayer()
{
	curPlayer++;
	curPlayer = curPlayer % players.size();
}

/*private static members*/
Game* Game::gameInstance;

int Game::mCellX = 5;
int Game::mCellY = 5;
#pragma once
#include "map.h"
#include "unit.h"
#include "viewport.h"
#include "pathfind.h"
#include "action.h"

class Game
{
private:
	
	bool running;

	//Camera Location
	double cx = 0;
	double cy = 0;

	Game();
	~Game();

	//Stuff we need for game
	Map* gameMap = nullptr;
	std::vector<GamePlayer> players;
	ViewPort viewPort;

	PathFinder* pathFinder = nullptr;

	int curPlayer = -1;
	int selUnit = -1;

	SDL_Point lastMouseCell{ -1,-1 };
	bool mouseDown;

	std::vector<Action*> actions;

	Uint64 now;
	Uint64 last;
private:
	void handleMouse();
	void click();
	void selectUnit(int sp, int su);
	//Gets the character at cell x,y (not mouse location)
	bool getCharacterAt(int cx, int cy, int& sPlayer, int& sUnit);
public: //static
	static void addAction(Action* action, Action *ref = nullptr);

public:
	static int mCellX, mCellY;
	static Game* gameInstance;
	
	static void Create();
	static void ProcessEvents();
	void Process();
	void StartUp(int x, int y);
	void NextPlayer();
	static inline bool IsRunning() { return gameInstance->running; }
};
#include "pch.h"
#include "gameplayer.h"

GamePlayer::GamePlayer()
{
	for (int i = 0; i < initUnits; i++)
	{
		units.push_back(Unit(((UnitType)i), 10 + rand() % 12, 5 + rand() % 12));
	}
}

std::string GamePlayer::GetJson() {
	std::string result = "{";
	for (int i = 0; i < initUnits; i++)
	{
		result += units[i].GetJson();
		if (i < (initUnits - 1)) result += ",";
		result += "\n";
	}
	result += "}\n";
	return result;
}#pragma once
#include "pch.h"
#include "unit.h"

class GamePlayer {
private:
	std::vector<Unit> units;
	//temp
	static constexpr int initUnits = 4;

public:
	GamePlayer();
	std::string GetJson();
	inline std::vector<Unit>& GetUnits()  { return units; }
	inline Unit& GetUnit(int idx) { return units[idx]; }
};
#include "pch.h"
#include "display.h"
#include "game.h"
#include "perlinmap.h"
#include <SDL_image.h>
#include "assetmgr.h"
#include "map.h"
#include "viewport.h"
#include "easywsclient.hpp"

#ifdef _WIN32
#pragma comment( lib, "ws2_32" )
#include <WinSock2.h>
#endif

#include <assert.h>
#include <stdio.h>
#include <string>
#include <memory>
#include "unit.h"



int nomain2()
{
    using easywsclient::WebSocket;
#ifdef _WIN32
    INT rc;
    WSADATA wsaData;
    rc = WSAStartup(MAKEWORD(2, 2), &wsaData);
    if (rc) {
        printf("WSAStartup Failed.\n");
        return 1;
    }
#endif
    

    //XXXC CRW need to thread this, thread safe queue for send/recv

    GamePlayer gp;
    std::unique_ptr<WebSocket> ws(WebSocket::from_url("ws://71.56.75.25:82/chat"));
    assert(ws);
    ws->send("goodbye");
    ws->send("hello");
    while (ws->getReadyState() != WebSocket::CLOSED) {
        WebSocket::pointer wsp = &*ws; // <-- because a unique_ptr cannot be copied into a lambda
        ws->poll();
        ws->dispatch([wsp,&gp](const std::string& message) {
            printf(">>> %s\n", message.c_str());
            if (message == "world") { wsp->close(); }

            //XXXC some bullshit.....
            //we got a message, lets reply with status
            std::string wtf = gp.GetJson();
            wsp->send(wtf);
            });
    }
#ifdef _WIN32
    WSACleanup();
#endif
    // N.B. - unique_ptr will free the WebSocket instance upon return:
    return 0;
}


int main(int argc, char* argv[])
{
    nomain2();
	if (SDL_Init(SDL_INIT_EVERYTHING) != 0)
	{
		std::cout << "Failed to init SDL " << SDL_GetError() << "\n";
		return -1;
	}
	

	Game::Create();
	Display::Create(1600, 800);
	IMG_Init(IMG_INIT_PNG);

	Game::gameInstance->StartUp(1600, 800);

	while (Game::IsRunning())
	{
		Game::ProcessEvents();
		Game::gameInstance->Process();
		Display::Present();
		SDL_Delay(11);
	}
	AssetMgr::Destroy();
	SDL_Quit();
	return 0;
}
#include "pch.h"
#include "map.h"
#include "perlinmap.h"

Map::Map()
{

}

void Map::Generate()
{
	PerlinMap noise(Size,Size);
	noise.Randomize(400000);
	noise.MakePerlin();
	noise.Normalize();

	for (int y = 0; y < Size; y++) {
		for (int x = 0; x < Size; x++) {
			int val =noise.GetTerrain(x, y, 9);
			
			map[y][x] = MapTile(val);
		}
	}

}

int Map::get(int x, int y)
{

	int val = map[y][x].GetTestCellVal();
	return val;
	
}

MapTile& Map::Get(int x, int y)
{
	return map[x][y];
}

#pragma once

#include "maptile.h"

class Map {
public:
	friend class PathFind;
	static constexpr int Size = 128;  //Need a power of 2......
	static constexpr int TileSize = 64;
private:
	MapTile map[Size][Size];
public:
	Map();
	void Generate();
	int get(int x, int y);
	MapTile& Get(int x, int y);
	//Stuff to get/set later
	bool highlighted = false;
};
#include "pch.h"
#include "maptile.h"
#include "assetmgr.h"
#include "map.h"
#include "unit.h"
#include "gameplayer.h"

int MapTile::getSpeed()
{

	switch (type) {
	case MapCellType::MARSH: return 3;
	case MapCellType::GRASS: return 1;
	case MapCellType::STEPPE: return 2;
	case MapCellType::HILL: return 7;
	case MapCellType::ROCKY: return 14;
	case MapCellType::DESTROYED: return 3;
	}
	//Impassable land...
	return 255;
}

MapTile::MapTile()
{

}

//Will have to figure out how to make it prettier
MapTile::MapTile(int val)
{
	imgOffset = rand() % 8;
	type = (MapCellType) val;
	speed = getSpeed();
}

MapTile::MapTile(MapCellType type)
{
	//this will work for now.....
	imgOffset = rand() % 8;
	this->type = type;
	speed = getSpeed();
}

void MapTile::Draw(SDL_Rect dest)
{
	SDL_Rect myRect;
	SDL_Texture* tempTex = AssetMgr::Get("LAND", Map::TileSize, imgOffset,(int) type, myRect);
	Display::DrawTexture(tempTex, &myRect, &dest);
	if (selected) {
		SDL_Texture* highlightTex = AssetMgr::Get("HIGHLIGHT", Map::TileSize, 0, 0, myRect);
		Display::DrawTexture(highlightTex, &myRect, &dest);

		//SDL_Texture* dude = AssetMgr::Get("UNITS", Map::TileSize, 0, 2, myRect);
		//Display::DrawTexture(dude, &myRect, &dest);
		
		//Unit dude(UnitType::Warrior);
		//dude.Draw(dest);

		GamePlayer myPlayer;
		myPlayer.GetUnits();
		
	}
}
#pragma once
#include "pch.h"

enum class MapCellType {
	DEEP_SEA = 0,
	WATER,
	SHALLOW_WATER,
	MARSH,
	GRASS,
	STEPPE,
	HILL,
	ROCKY,
	SNOW,
	NONE,
	DESTROYED
};

//This is a location on the map, stored inside the map
class MapTile {
private:
	MapCellType type = MapCellType::NONE;
	int imgOffset = 0;
	friend class PathFind;
	int speed = 99;
	int getSpeed();
public:
	bool selected = false;
	MapTile();
	MapTile(int val);
	MapTile(MapCellType type);
	void Draw(SDL_Rect dest);
	inline int GetTestCellVal() { return (int)type; }
	inline int GetTestCellOfs() { return imgOffset; }
	inline int GetSpeed() { return speed; }

};
#include "pch.h"
#include "pathfind.h"
#include <set>



PathFinder::PathFinder(Map& imap) : map(imap)
{
	dRange = new std::array<std::array<int, Map::Size>, Map::Size>();
}

void PathFinder::DoUnitMaxDistanceTravel(const Unit& who, int val)
{
	ResetMap();
	calcFlood(who.GetX(),who.GetY(),who.GetSpeed());
}

void PathFinder::DoUnitMaxDistanceAttack(const Unit& who, int val, bool aerial)
{

}

int PathFinder::GetRange(int x, int y)
{
	return (*dRange)[y][x];
}

void PathFinder::ResetMap()
{
	for (int y = 0; y < Map::Size; y++) {
		for (int x = 0; x < Map::Size; x++) {
			//These are just other ways to access it...
			//dMap->at(j).at(i) = -1;
			//dMap->at(j)[i] = -1;
			//(*dMap)[y][x] = -1;
			(*dRange)[y][x] = -1;
		}
	}
}

PathFinder::xyRange PathFinder::pathGood(int x, int y)
{
	int d = ((*dRange)[y][x]);
	if (d < 0) d = Map::Size*2+1;
	return xyRange{ x,y,d };
}

/// <summary>
/// Get path to starts at x, y, and ends at pathfinder 0.  
/// This shall not be called if a path is not already possible.
/// </summary>
/// <param name="x">target x cell</param>
/// <param name="y">targer y cell</param>
/// <returns></returns>
std::vector<SDL_Point> PathFinder::GetPathTo(int x, int y)
{
	int sx = x;
	int sy = y;
	typedef std::tuple<int, int, int> xyRange;
	std::list<xyRange> found;

	std::vector<SDL_Point> thePath;
	//This is out starting location.
	
	thePath.push_back(SDL_Point{ x,y });

	//It's zero when we find the target
	while ((*dRange)[y][x] > 1)
	{
		int d = (*dRange)[y][x];

		std::cout << "Pos" << x << "," << y << " Dist: " << d << "\n";

		found.push_back(pathGood(x, y - 1));
		found.push_back(pathGood(x, y + 1));
		found.push_back(pathGood(x - 1, y));
		found.push_back(pathGood(x + 1, y));

		found.sort([]( xyRange& a, xyRange& b) {
			return std::get<2>(a) < std::get<2>(b); 
			});

		int d1;
		std::tie(x, y, d1) = found.front();

		d = d1;
		found.clear();
		//thePath.insert(thePath.begin(), SDL_Point{ x,y });
		thePath.push_back( SDL_Point{ x,y });
		if (thePath.size() > 20) {
			int bp = 0;
		}
	}
	return thePath;
}

bool PathFinder::rangeOpen(int x, int y, int& speed)
{
	speed = 255;
	if (x < 0) return false;
	if (y < 0) return false;
	if (x >= Map::Size) return false;
	if (y >= Map::Size) return false;
	speed = map.Get(x, y).GetSpeed();
	if (speed < 99) {
		int bp = 0;
	}
	//if (((*dMap)[x][y]) != 0) return false;
	if (((*dRange)[y][x]) == -1) return true;
	return false;

}

void PathFinder::calcFlood(int x, int y, int maxSpeed)
{
	typedef std::tuple<int, int, int> xyRange;
	std::set<xyRange> found;
	found.insert(xyRange(x, y, 1));
	int speed = 0;
	while (found.size() > 0)
	{
		std::set<xyRange> mainSet;
		int sx, sy, d;
		for (xyRange xyz : found) {
			std::tie(sx, sy, d) = xyz;
			//Set this spot.
			(*dRange)[sy][sx] = d;
			if (rangeOpen(sx, sy - 1, speed)) mainSet.insert(xyRange(sx, sy - 1, d + speed));
			if (rangeOpen(sx, sy + 1, speed)) mainSet.insert(xyRange(sx, sy + 1, d + speed));
			if (rangeOpen(sx + 1, sy, speed)) mainSet.insert(xyRange(sx + 1, sy, d + speed));
			if (rangeOpen(sx - 1, sy, speed)) mainSet.insert(xyRange(sx - 1, sy, d + speed));
		}
		found.clear();
		for (xyRange xy : mainSet) {
			std::tie(sx, sy, d) = xy;
			bool isFound = false;
			//Figure out if that position is already found, we don't want to search 2-20x.
			//double searching makes bad paths.
			for (auto position : found) {
				int isx, isy, isd;
				std::tie(isx, isy, isd) = position;
				if ((sx == isx) && (sy == isy)) {
					isFound = true;
					break;
				}
			}
			if (!isFound) {
				//Check our max speed now
				if (d <= maxSpeed) {
					found.insert(xy);
				}
			}
			else {
				int bp = 0;
			}
		}
		mainSet.clear();
	}
}

PathFinder::~PathFinder()
{
	delete dRange;
}#pragma once

#include "pch.h"
#include "maptile.h"
#include "map.h"
#include <vector>
#include "unit.h"



class PathFinder {
private:
    typedef std::tuple<int, int, int> xyRange;

    std::array<std::array<int, Map::Size>, Map::Size>* dRange = nullptr;
    std::vector<SDL_Point> path;
    
    void calcFlood(int x, int y, int maxSpeed);
    bool rangeOpen(int x, int y, int &speed);
    Map& map;
    xyRange pathGood(int x, int y);
public:
    PathFinder(Map& map);
    void DoUnitMaxDistanceTravel(const Unit& who, int val);
    void DoUnitMaxDistanceAttack(const Unit& who, int val, bool aerial);
    void ResetMap();

    

    //Current unit is selected, so this should be simple....
    std::vector<SDL_Point> GetPathTo(int x, int y);

    
    /// <summary>
    /// Returns the distance from calculated path.
    /// </summary>
    /// <param name="x"></param>
    /// <param name="y"></param>
    /// <returns>Returns the distance from calculated path.</returns>
    int GetRange(int x, int y);
    
    ~PathFinder();
};
#include "pch.h"#pragma once

#include <array>
#include <list>
#include <string>
#include <vector>
   
#include <iostream>
#include <sstream>
#include <fstream>

#include <functional>
#include <memory>
#include <map>

#include <SDL.h>
#pragma once
#include "pch.h"
#include "perlinmap.h"
#include <random>
#include "display.h"

PerlinMap::PerlinMap(int x, int y)
{
	width = x;
	height = y;

	evalues = new float[(size_t)x * y];
	svalues = new float[(size_t)x * y];
}

PerlinMap::~PerlinMap()
{
    if (svalues) delete[] svalues;
    if (evalues) delete[] evalues;
}

void PerlinMap::MakePerlin()
{
	float fbias = 2.0f;
	for (int x = 0; x < width; x++) {
		for (int y = 0; y < height; y++)
		{
			float fNoise = 0.0f;
			float fScaleAcc = 0.0f;
			float fScale = 1.0f;

			for (int o = 0; o < (octaves-1); o++)
			{
				int nPitch = width >> o;
				int nSampleX1 = (x / nPitch) * nPitch;
				int nSampleY1 = (y / nPitch) * nPitch;

				int nSampleX2 = (nSampleX1 + nPitch) % width;
				int nSampleY2 = (nSampleY1 + nPitch) % width;

				float fBlendX = (float)(x - nSampleX1) / (float)nPitch;
				float fBlendY = (float)(y - nSampleY1) / (float)nPitch;

				float fSampleT = (1.0f - fBlendX) * svalues[nSampleY1 * width + nSampleX1] + fBlendX * svalues[nSampleY1 * width + nSampleX2];
				float fSampleB = (1.0f - fBlendX) * svalues[nSampleY2 * width + nSampleX1] + fBlendX * svalues[nSampleY2 * width + nSampleX2];

				fScaleAcc += fScale;
				fNoise += (fBlendY * (fSampleB - fSampleT) + fSampleT) * fScale;
				fScale = fScale / fbias;
			}
			// Scale it
			evalues[y * width + x] = fNoise / fScaleAcc;
		}
	}
}

void PerlinMap::Normalize()
{
	float max = -100.0f;
	float min = 100.0f;
	for (int i = 0; i < (width * height); i++) {
		if (evalues[i] > max) max = evalues[i];
		if (evalues[i] < min) min = evalues[i];
	}
	float diff = max - min;
	float mult = 1 / diff;
	for (int i = 0; i < (width * height); i++) {
		evalues[i] -= min;
		evalues[i] *= mult;
	}
}



int PerlinMap::GetTerrain(int x, int y, int max)
{
	//Scale to requested level
	int val = (int)(evalues[y * width + x] * max);

	if (val < 0) val = 0;
	if (val >= max) val = max - 1;
	return val;
}

//static
void PerlinMap::TestDraw()
{
	/*
	int w = 512;
	int h = 512;
	int rval = rand() % 500;
	PerlinMap map = PerlinMap(w, h);
	map.Randomize(107);
	map.MakePerlin();
	map.Normalize();
	SDL_Renderer* ren = Display::GetRenderer();
	//now to draw it.........   ugh
	for (int y = 0; y < h; y++) {
		for (int x = 0; x < w; x++) {
			int val = map.GetTerrain(x, y, 8) * 32;
			if (val > 255) val = 255;
			if (val < 0) val = 0;
			SDL_SetRenderDrawColor(ren, val, val, val, 255);
			SDL_RenderDrawPoint(ren, x, y);
		}
	}
	*/
}

void PerlinMap::Randomize(int iseed)
{
    std::mt19937 gen(iseed);
    std::uniform_real_distribution<> dis(0.0, 1.0);
    for (int x = 0; x < width; x++) {
        for (int y = 0; y < height; y++) {
            svalues[y * width + x] = dis(gen);
        }
    }
}

#pragma once



/// <summary>
/// Do not use new on this.  Just put it on the stack.  Loop through until paths are verified, then go out of scope.
/// </summary>
class PerlinMap {
private:
	int seed = 0;
	int width = 0;
	int height = 0;
	float* svalues = nullptr;
	float* evalues = nullptr;
	const int octaves = 6;
public:
	PerlinMap(int x, int y);
	~PerlinMap();
	/// <summary>
	/// Randomizes the source numbers, taking a new seed - if 
	/// </summary>
	void Randomize(int seed);
	void MakePerlin();
	void Normalize();
	//this will be enum soon
	int GetTerrain(int x, int y, int max);
	static void TestDraw();
};#pragma once

#include <queue>
#include <mutex>
#include <condition_variable>

// A threadsafe-queue.
template <class T>
class ThreadQueue
{
public:
    ThreadQueue(void)
        : q()
        , m()
        , c()
    {}

    ~ThreadQueue(void)
    {}

    // Add an element to the queue.
    void enqueue(T t)
    {
        std::lock_guard<std::mutex> lock(m);
        q.push(t);
        c.notify_one();
    }
    // Get the "front"-element.
    // If the queue is empty, wait till a element is avaiable.
    T dequeue(void)
    {
        std::unique_lock<std::mutex> lock(m);
        while (q.empty())
        {
            // release lock as long as the wait and reaquire it afterwards.
            c.wait(lock);
        }
        T val = q.front();
        q.pop();
        return val;
    }
private:
    std::queue<T> q;
    mutable std::mutex m;
    std::condition_variable c;
};
#include "pch.h"
#include "action.h"


bool ActionPlayLocal::Process(double time)
{
    return false;
}

void ActionPlayLocal::Click()
{
}

ActionMovePlayer::ActionMovePlayer(Unit& who, int x, int y): actor(who)
{
    tx = x;
    ty = y;
}

bool ActionMovePlayer::Process(double time)
{
    float dx = tx - actor.GetXF();
    float dy = ty - actor.Ge#include "pch.h"
#include "unit.h"
#include "map.h"
#include "display.h"
#include "assetmgr.h"

Unit::Unit(UnitType type, int x, int y)
{
	this->type = type;

	this->x = x;
	this->y = y;

	texture = AssetMgr::Get("UNITS", Map::TileSize, 0, (int)type, rect);

	weapon = WeaponType::None;
	hp = 0;
	speed = 0;
	range = 0;
	damage = 0.0f;

	//Weapon type and stats depend on unit type.
	switch (type)
	{
	case UnitType::Warrior:
		weapon = WeaponType::Melee;
		hp = 100.0f;
		speed = 12;
		range = 1;
		damage = 20.0f;
		break;

	case UnitType::Spear:
		weapon = WeaponType::Melee;
		hp = 100.0f;
		speed = 24;
		range = 1;
		damage = 35.0f;
		break;

	case UnitType::Archer:
		weapon = WeaponType::Ranged;
		hp = 75.0f;
		speed = 30;
		range = 5;
		damage = 20.0f;
		break;

	case UnitType::Wizard:
		weapon = WeaponType::Magic;
		hp = 50.0f;
		speed = 20;
		range = 2;
		damage = 40.0f;
		break;
	}
}

std::string jsonify(std::string key, std::string value) {
	std::string result = "";
	result += " \""+key+"\": \"";
	result += value + "\"";
	return result;
}

std::string Unit::GetJson()
{
	std::string result = "{\r\n";
	result += jsonify("hp", std::to_string(hp));
	result += ",\r\n";
	result += jsonify("x", std::to_string(GetX()));
	result += ",\r\n";
	result += jsonify("y", std::to_string(GetY()));
	result += "\r\n";
	result += "}\r\n";
	return result;
}

void Unit::Draw(SDL_Rect dest)
{
	Display::DrawTexture(texture, &rect, &dest);
}
#pragma once
#include "pch.h"
#include <string>

enum class UnitType {
	Warrior = 0,
	Spear,
	Archer,
	Wizard,
};

enum class WeaponType
{
	None = 0,
	Melee,
	Ranged,
	Magic
};

class Unit {
private:
	UnitType type;
	WeaponType weapon;
	SDL_Rect rect;
	SDL_Texture* texture;

	int hp = 50;
	//Speed is how many regular tiles it can travel per round/Tile slowness.
	int speed = 20;

	int constitution = 50;
	int range;
	float damage;

	float x=1;
	float y=2;

public:
	static constexpr int ConstMax = 50;
	Unit(UnitType type, int x, int y);
	std::string GetJson();
	void Draw(SDL_Rect dest);

	inline int GetX() const { return (int) x+.5f; }
	inline int GetY() const { return (int) y+.5f; }
	//These return the float positions.
	inline float GetXF() const { return x; }
	inline float GetYF() const { return y; }

	inline int GetSpeed() const { return speed; }
	inline void Move(int dx, int dy) {
		x = dx; y = dy;
	}
	//This is for animations, to partial move the character.
	inline void MoveF(float dx, float dy) {
		x = dx; y = dy;
	}

};#include "pch.h"
#include "viewport.h"
#include "assetmgr.h"
#include "game.h"

bool cellDistanceShow = false;


ViewPort::ViewPort(int x, int y, int w, int h, float zoom)
{
	topX = x; topY = y; width = w; height = h;
	zoom = 1.0f;
	camTX = 0;
	camTY = 0;
	camX = 0;
	camY = 0;
	
}




void ViewPort::SetCamera(double &x, double &y)
{
	if (x < 0) x = 0;
	if (y >= 1) y = 1;
	if (x >= 1) x = 1;
	if (y <= 0) y = 0;
	camTX = x ;
	camTY = y ;
}

//Ghetto cam pan
void ViewPort::Update(int ms)
{
	float delay = 9.0f;
	camX = ((camX*delay + camTX) / (delay+1.0f));
	camY = ((camY*delay + camTY) / (delay+1.0f));
}

int asdf = 0;
void ViewPort::Draw(Map& map, std::vector<GamePlayer> players, PathFinder *pathFinder)
{
	SDL_ClipRectSection myClip(topX, topY, width, height);
	SDL_Rect destRect;
	destRect.w = Map::TileSize;
	destRect.h = Map::TileSize;
	int maxXCells = width / destRect.w;
	int maxYCells = height / destRect.h;
	
	//Camera X/Y in cell grid location
	int cx = (int)(camX * Map::Size );
	int cy = (int)(camY * Map::Size );

	//Camera X/Y in pixel location
	int MScx = (int)(camX * Map::Size * Map::TileSize);
	int MScy = (int)(camY * Map::Size * Map::TileSize);
	
	//Cell grid offset from 0,0 of each cell
	int pcx = MScx % (Map::TileSize);
	int pcy = MScy % (Map::TileSize);
	
	if (cx < 0) cx = 0;
	if (cy < 0) cy = 0;
	
	int maxXCam = Map::Size - (width / Map::TileSize) -1;
	int maxYCam = Map::Size - (height / Map::TileSize) -1;

	if (cx > (maxXCam)) cx = maxXCam;
	if (cy > (maxYCam)) cy = maxYCam;
	
	for (int y = 0; y < maxYCells+2 /* scale*/; y++) {
		for (int x = 0; x < maxXCells+1/*scale*/; x++) {
			destRect.x = x * Map::TileSize + topX -pcx;
			destRect.y = y * Map::TileSize + topY -pcy;
			map.Get(cx + x, cy + y).Draw(destRect);

			//Now we need to handle the cells in the pathfinder.....
			if (pathFinder->GetRange(cx + x, cy + y) > 0) {
				SDL_Rect myRect;
				SDL_Texture* highlightTex = AssetMgr::Get("HIGHLIGHT", Map::TileSize, 0, 2, myRect);
				Display::DrawTexture(highlightTex, &myRect, &destRect);

				//This is for testing only....
				if (cellDistanceShow) {
					DrawNumer(destRect, pathFinder->GetRange(cx + x, cy + y));
				}
			}
			//Highlight Current Cell under the mouse.........
			if ((Game::mCellX == (cx + x)) && ((Game::mCellY == cy + y))) {
				SDL_Rect myRect;
				SDL_Texture* highlightTex = AssetMgr::Get("HIGHLIGHT", Map::TileSize, 0, 0, myRect);
				Display::DrawTexture(highlightTex, &myRect, &destRect);
			}
		}
	}

	for (auto& player : players)
	{
		for (auto unit : player.GetUnits())
		{
			destRect.x =(int) ((unit.GetXF()-(float)cx ) * (float)Map::TileSize + (float)topX - (float)pcx);
			destRect.y =(int) ((unit.GetYF()-(float)cy ) * (float)Map::TileSize + (float)topY - (float)pcy);
			unit.Draw(destRect);
		}
	}
}

void ViewPort::DoSomething()
{
	///some code......................
}
/// <summary>
/// 
/// </summary>
/// <param name="mx">Mouse x</param>
/// <param name="my">Mouse y</param>
/// <param name="x">Ref OUT cell x</param>
/// <param name="y">Ref OUT cell y</param>
/// <returns>Cell location in map of map cell under cursor.....</returns>
bool ViewPort::GetCellAtMouseXY(int mx, int my, int& x, int& y)
{
	
	mx -= topX;
	my -= topY;

	mx = (int)(Map::Size*Map::TileSize * camX + mx) / Map::TileSize;
	my = (int)(Map::Size*Map::TileSize * camY + my) / Map::TileSize;

	if (camX > .1) {
		int bp = 0;
	}

	x = mx;
	y = my;

	return false;
}

void ViewPort::RenderTextureAt(int cx, int cy, int ocx, int ocy, SDL_Texture* tex, SDL_Rect* sourceRect)
{
	return;
}

bool ViewPort::MouseInViewPort(int x, int y)
{
	if (x < topX) return false;
	if (y < topY) return false;
	if (x >= (topX + width)) return false;
	if (y >= (topY + height)) return false;
	return true;
}

void ViewPort::DrawNumer(SDL_Rect location, int value)
{
	int x = location.x;
	int y = location.y;
	char buf[80];
	snprintf(buf,15,"%d",  value);
	//char* temp = itoa(value);
	for (char c : buf) {
		SDL_Rect myRect;
		SDL_Rect textRect;
		textRect.x = x;
		textRect.y = y;
		textRect.w = 16;
		textRect.h = 16;
		SDL_Texture* fontText = AssetMgr::Get("FONT16", 16, (c - '0'), 0, myRect);
		Display::DrawTexture(fontText, &myRect, &textRect);
		x += 16;
	}
}
#pragma once
#include "pch.h"
#include "map.h"
#include "unit.h"
#include "gameplayer.h"
#include "pathfind.h"

class ViewPort {
private:
	int topX=0, topY=0;
	int width=0, height=0;
	float zoom = 1.0f;
	//Camera Location
	double camX=0.0, camY=0.0;  
	double camTX=0.0, camTY=0.0;
public:
	ViewPort(int x, int y, int w, int h, float zoom);
	ViewPort() = default;
	
	void SetCamera(double& x, double& y);
	void Update(int ms);
	void Draw(Map& map, std::vector<GamePlayer> players, PathFinder *pathFinder);
	void DoSomething();
	bool GetCellAtMouseXY(int mx, int my, int& x, int& y);
	void RenderTextureAt(int cx, int cy, int ocx, int ocy, SDL_Texture* tex, SDL_Rect* sourceRect);
	bool MouseInViewPort(int x, int y);
	void DrawNumer(SDL_Rect location, int value);





};
#include "pch.h"
#include "unit.h"


class Action {
public:
	//Returns true if Process is complete.
	virtual bool Process(double time) = 0;
	virtual void Click() = 0;
	Action();
	
};

class ActionPlayLocal : public Action {
	bool Process(double time);
	void Click();
};



class ActionMovePlayer : public Action {
	int tx, ty;
	Unit& actor;
public:
	ActionMovePlayer(Unit& who, int x, int y);
	bool Process(double time);
	void Click();
};


//XXXC CRW  Need action request, action join, action waiting, action playing and action 
//game over.  Also have to do point inserts on action lists.
#pragma once

class Animation
{
private:

public:
	virtual ~Animation() = default;

	virtual void Start() = 0;
};

class AnimationArrow : public Animation
{
private:
public:
};#pragma once
#include "pch.h"
#include "display.h"
#include "SDL_image.h"

class AssetMgr {
private:
	
	
	
public:
	static void Destroy();
	static std::map<std::string, SDL_Texture*> Images;
	static bool Load(std::string filename, std::string nick);
	static SDL_Texture* Get(std::string nick, int gridSize, int x, int y, SDL_Rect& dest);
	static SDL_Texture* GetAll(std::string nick, SDL_Rect& dest);
};

#pragma once
#include "pch.h"

class Display
{
private:
	static Display* displayInstance;

	SDL_Window* window;
	SDL_Renderer* renderer;

	int width;
	int height;

	Display(int width, int height);
	~Display();

public:

	static void Create(int width, int height);

	static void Clear(Uint8 r, Uint8 g, Uint8 b);
	static void Present();
	
	static void DrawTexture(SDL_Texture* texture);
	static void DrawTexture(SDL_Texture* texture, const SDL_Rect* targetRect);
	static void DrawTexture(SDL_Texture* texture, const SDL_Rect* targetRect, const SDL_Rect* subTexture);

	static inline SDL_Window* GetWindow() { return displayInstance->window; }
	static inline SDL_Renderer* GetRenderer() { return displayInstance->renderer; }
};


class SDL_ClipRectSection {
	SDL_Rect oldRect;
public:
	SDL_ClipRectSection(int x, int y, int w, int h);
	~SDL_ClipRectSection(); 
};#ifndef EASYWSCLIENT_HPP_20120819_MIOFVASDTNUASZDQPLFD
#define EASYWSCLIENT_HPP_20120819_MIOFVASDTNUASZDQPLFD

// This code comes from:
// https://github.com/dhbaird/easywsclient
//
// To get the latest version:
// wget https://raw.github.com/dhbaird/easywsclient/master/easywsclient.hpp
// wget https://raw.github.com/dhbaird/easywsclient/master/easywsclient.cpp

#include <string>
#include <vector>

namespace easywsclient {

struct Callback_Imp { virtual void operator()(const std::string& message) = 0; };
struct BytesCallback_Imp { virtual void operator()(const std::vector<uint8_t>& message) = 0; };

class WebSocket {
  public:
    typedef WebSocket * pointer;
    typedef enum readyStateValues { CLOSING, CLOSED, CONNECTING, OPEN } readyStateValues;

    // Factories:
    static pointer create_dummy();
    static pointer from_url(const std::string& url, const std::string& origin = std::string());
    static pointer from_url_no_mask(const std::string& url, const std::string& origin = std::string());

    // Interfaces:
    virtual ~WebSocket() { }
    virtual void poll(int timeout = 0) = 0; // timeout in milliseconds
    virtual void send(const std::string& message) = 0;
    virtual void sendBinary(const std::string& message) = 0;
    virtual void sendBinary(const std::vector<uint8_t>& message) = 0;
    virtual void sendPing() = 0;
    virtual void close() = 0;
    virtual readyStateValues getReadyState() const = 0;

    template<class Callable>
    void dispatch(Callable callable)
        // For callbacks that accept a string argument.
    { // N.B. this is compatible with both C++11 lambdas, functors and C function pointers
        struct _Callback : public Callback_Imp {
            Callable& callable;
            _Callback(Callable& callable) : callable(callable) { }
            void operator()(const std::string& message) { callable(message); }
        };
        _Callback callback(callable);
        _dispatch(callback);
    }

    template<class Callable>
    void dispatchBinary(Callable callable)
        // For callbacks that accept a std::vector<uint8_t> argument.
    { // N.B. this is compatible with both C++11 lambdas, functors and C function pointers
        struct _Callback : public BytesCallback_Imp {
            Callable& callable;
            _Callback(Callable& callable) : callable(callable) { }
            void operator()(const std::vector<uint8_t>& message) { callable(message); }
        };
        _Callback callback(callable);
        _dispatchBinary(callback);
    }

  protected:
    virtual void _dispatch(Callback_Imp& callable) = 0;
    virtual void _dispatchBinary(BytesCallback_Imp& callable) = 0;
};

} // namespace easywsclient

#endif /* EASYWSCLIENT_HPP_20120819_MIOFVASDTNUASZDQPLFD */
#pragma once
#include "map.h"
#include "unit.h"
#include "viewport.h"
#include "pathfind.h"
#include "action.h"

class Game
{
private:
	
	bool running;

	//Camera Location
	double cx = 0;
	double cy = 0;

	Game();
	~Game();

	//Stuff we need for game
	Map* gameMap = nullptr;
	std::vector<GamePlayer> players;
	ViewPort viewPort;

	PathFinder* pathFinder = nullptr;

	int curPlayer = -1;
	int selUnit = -1;

	SDL_Point lastMouseCell{ -1,-1 };
	bool mouseDown;

	std::vector<Action*> actions;

	Uint64 now;
	Uint64 last;
private:
	void handleMouse();
	void click();
	void selectUnit(int sp, int su);
	//Gets the character at cell x,y (not mouse location)
	bool getCharacterAt(int cx, int cy, int& sPlayer, int& sUnit);
public: //static
	static void addAction(Action* action, Action *ref = nullptr);

public:
	static int mCellX, mCellY;
	static Game* gameInstance;
	
	static void Create();
	static void ProcessEvents();
	void Process();
	void StartUp(int x, int y);
	void NextPlayer();
	static inline bool IsRunning() { return gameInstance->running; }
};
#pragma once
#include "pch.h"
#include "unit.h"

class GamePlayer {
private:
	std::vector<Unit> units;
	//temp
	static constexpr int initUnits = 4;

public:
	GamePlayer();
	std::string GetJson();
	inline std::vector<Unit>& GetUnits()  { return units; }
	inline Unit& GetUnit(int idx) { return units[idx]; }
};
#pragma once

#include "maptile.h"

class Map {
public:
	friend class PathFind;
	static constexpr int Size = 128;  //Need a power of 2......
	static constexpr int TileSize = 64;
private:
	MapTile map[Size][Size];
public:
	Map();
	void Generate();
	int get(int x, int y);
	MapTile& Get(int x, int y);
	//Stuff to get/set later
	bool highlighted = false;
};
#pragma once
#include "pch.h"

enum class MapCellType {
	DEEP_SEA = 0,
	WATER,
	SHALLOW_WATER,
	MARSH,
	GRASS,
	STEPPE,
	HILL,
	ROCKY,
	SNOW,
	NONE,
	DESTROYED
};

//This is a location on the map, stored inside the map
class MapTile {
private:
	MapCellType type = MapCellType::NONE;
	int imgOffset = 0;
	friend class PathFind;
	int speed = 99;
	int getSpeed();
public:
	bool selected = false;
	MapTile();
	MapTile(int val);
	MapTile(MapCellType type);
	void Draw(SDL_Rect dest);
	inline int GetTestCellVal() { return (int)type; }
	inline int GetTestCellOfs() { return imgOffset; }
	inline int GetSpeed() { return speed; }

};
#pragma once

#include "pch.h"
#include "maptile.h"
#include "map.h"
#include <vector>
#include "unit.h"



class PathFinder {
private:
    typedef std::tuple<int, int, int> xyRange;

    std::array<std::array<int, Map::Size>, Map::Size>* dRange = nullptr;
    std::vector<SDL_Point> path;
    
    void calcFlood(int x, int y, int maxSpeed);
    bool rangeOpen(int x, int y, int &speed);
    Map& map;
    xyRange pathGood(int x, int y);
public:
    PathFinder(Map& map);
    void DoUnitMaxDistanceTravel(const Unit& who, int val);
    void DoUnitMaxDistanceAttack(const Unit& who, int val, bool aerial);
    void ResetMap();

    

    //Current unit is selected, so this should be simple....
    std::vector<SDL_Point> GetPathTo(int x, int y);

    
    /// <summary>
    /// Returns the distance from calculated path.
    /// </summary>
    /// <param name="x"></param>
    /// <param name="y"></param>
    /// <returns>Returns the distance from calculated path.</returns>
    int GetRange(int x, int y);
    
    ~PathFinder();
};
#pragma once

#include <array>
#include <list>
#include <string>
#include <vector>
   
#include <iostream>
#include <sstream>
#include <fstream>

#include <functional>
#include <memory>
#include <map>

#include <SDL.h>
#pragma once



/// <summary>
/// Do not use new on this.  Just put it on the stack.  Loop through until paths are verified, then go out of scope.
/// </summary>
class PerlinMap {
private:
	int seed = 0;
	int width = 0;
	int height = 0;
	float* svalues = nullptr;
	float* evalues = nullptr;
	const int octaves = 6;
public:
	PerlinMap(int x, int y);
	~PerlinMap();
	/// <summary>
	/// Randomizes the source numbers, taking a new seed - if 
	/// </summary>
	void Randomize(int seed);
	void MakePerlin();
	void Normalize();
	//this will be enum soon
	int GetTerrain(int x, int y, int max);
	static void TestDraw();
};#pragma once

#include <queue>
#include <mutex>
#include <condition_variable>

// A threadsafe-queue.
template <class T>
class ThreadQueue
{
public:
    ThreadQueue(void)
        : q()
        , m()
        , c()
    {}

    ~ThreadQueue(void)
    {}

    // Add an element to the queue.
    void enqueue(T t)
    {
        std::lock_guard<std::mutex> lock(m);
        q.push(t);
        c.notify_one();
    }
    // Get the "front"-element.
    // If the queue is empty, wait till a element is avaiable.
    T dequeue(void)
    {
        std::unique_lock<std::mutex> lock(m);
        while (q.empty())
        {
            // release lock as long as the wait and reaquire it afterwards.
            c.wait(lock);
        }
        T val = q.front();
        q.pop();
        return val;
    }
private:
    std::queue<T> q;
    mutable std::mutex m;
    std::condition_variable c;
};
#pragma once
#include "pch.h"
#include <string>

enum class UnitType {
	Warrior = 0,
	Spear,
	Archer,
	Wizard,
};

enum class WeaponType
{
	None = 0,
	Melee,
	Ranged,
	Magic
};

class Unit {
private:
	UnitType type;
	WeaponType weapon;
	SDL_Rect rect;
	SDL_Texture* texture;

	int hp = 50;
	//Speed is how many regular tiles it can travel per round/Tile slowness.
	int speed = 20;

	int constitution = 50;
	int range;
	float damage;

	float x=1;
	float y=2;

public:
	static constexpr int ConstMax = 50;
	Unit(UnitType type, int x, int y);
	std::string GetJson();
	void Draw(SDL_Rect dest);

	inline int GetX() const { return (int) x+.5f; }
	inline int GetY() const { return (int) y+.5f; }
	//These return the float positions.
	inline float GetXF() const { return x; }
	inline float GetYF() const { return y; }

	inline int GetSpeed() const { return speed; }
	inline void Move(int dx, int dy) {
		x = dx; y = dy;
	}
	//This is for animations, to partial move the character.
	inline void MoveF(float dx, float dy) {
		x = dx; y = dy;
	}

};#pragma once
#include "pch.h"
#include "map.h"
#include "unit.h"
#include "gameplayer.h"
#include "pathfind.h"

class ViewPort {
private:
	int topX=0, topY=0;
	int width=0, height=0;
	float zoom = 1.0f;
	//Camera Location
	double camX=0.0, camY=0.0;  
	double camTX=0.0, camTY=0.0;
public:
	ViewPort(int x, int y, int w, int h, float zoom);
	ViewPort() = default;
	
	void SetCamera(double& x, double& y);
	void Update(int ms);
	void Draw(Map& map, std::vector<GamePlayer> players, PathFinder *pathFinder);
	void DoSomething();
	bool GetCellAtMouseXY(int mx, int my, int& x, int& y);
	void RenderTextureAt(int cx, int cy, int ocx, int ocy, SDL_Texture* tex, SDL_Rect* sourceRect);
	bool MouseInViewPort(int x, int y);
	void DrawNumer(SDL_Rect location, int value);





};
